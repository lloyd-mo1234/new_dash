<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trading Dashboard</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        .trading-container {
            display: grid;
            grid-template-columns: 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 2px;
            height: calc(100vh - 60px);
            padding: 2px;
            background: var(--bg-tool-area);
        }
        
        .charts-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2px;
        }
        
        .trading-panel {
            background: var(--bg-tool-area);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            overflow: auto;
        }
        
        .trading-panel.portfolio-chart,
        .trading-panel.instrument-chart {
            border: none;
            padding: 0;
            margin: 0;
        }
        
        .trades-panel {
            grid-column: 1;
            grid-row: 1;
        }
        
        .regression-table {
            grid-column: 2;
            grid-row: 1;
        }
        
        .portfolio-chart {
            grid-column: 1;
            grid-row: 2;
        }
        
        .instrument-chart {
            grid-column: 2;
            grid-row: 2;
        }
        
        .trade-form {
            display: flex;
            gap: 1px;
            margin-bottom: 20px;
            align-items: end;
        }
        
        .form-group {
            display: flex;
            flex-direction: column;
        }
        
        .form-group label {
            color: #ffffff;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        .form-group input, .form-group select {
            padding: 5px 11px;
            border: none;
            border-radius: 4px;
            background: #1e1e1e;
            color: #00d4ff;
            font-size: 12px;
            height: 19px;
            box-sizing: border-box;
        }
        
        /* Standard input width (same as clear button) */
        .form-group.standard input,
        .form-group.standard select {
            width: 67px;
        }
        
        /* 2x width for identifier */
        .form-group.double input {
            width: 134px;
        }
        
        /* 4x width for primary and secondary instruments */
        .form-group.quad input {
            width: 268px;
        }
        
        .btn {
            padding: 5px 11px;
            background: transparent;
            border: none;
            border-radius: 0px;
            cursor: pointer;
            font-size: 9px;
            transition: background-color 0.3s;
            color: var(--text-primary);
        }
        
        .btn:hover {
            background: var(--accent-hover);
            border-radius: 0px;
        }
        
        .btn-primary {
            background: transparent;
            color: var(--text-primary);
        }
        
        .btn-primary:hover {
            background: var(--accent-hover);
            border-radius: 0px;
        }
        
        .btn-secondary {
            background: transparent;
            color: var(--text-primary);
        }
        
        .btn-secondary:hover {
            background: var(--accent-hover);
        }
        
        .btn-danger {
            background: #dc3545;
            color: white;
        }
        
        .btn-danger:hover {
            background: #c82333;
        }
        
        .btn-remove {
            background: transparent;
            color: #ff6b6b;
            border: none;
            padding: 2px 6px;
            font-size: 10px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        .btn-remove:hover {
            background: rgba(255, 107, 107, 0.1);
        }
        
        .btn-pnl {
            background: transparent;
            color: #00d4ff;
            border: none;
            padding: 2px 6px;
            font-size: 10px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        .btn-pnl:hover {
            background: rgba(0, 212, 255, 0.1);
        }
        
        .trades-list {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 20px;
        }
        
        .trade-item {
            background: #1e1e1e;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 10px;
        }
        
        .trade-item h4 {
            margin: 0 0 10px 0;
            color: #00d4ff;
        }
        
        .trade-details {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            font-size: 12px;
        }
        
        .regression-inputs {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .regression-table-container {
            overflow-x: auto;
        }
        
        .regression-table-data {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }
        
        .regression-table-data th,
        .regression-table-data td {
            border: 1px solid #444;
            padding: 8px;
            text-align: center;
        }
        
        .regression-table-data th {
            background: #1e1e1e;
            color: #00d4ff;
        }
        
        .regression-table-data td {
            background: #2d2d2d;
        }
        
        .chart-container {
            height: 100%;
            min-height: 300px;
        }
        
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
        }
        
        .modal-content {
            background-color: #1a1a1a;
            margin: 5% auto;
            padding: 20px;
            border: none;
            border-radius: 0px;
            width: 80%;
            max-width: 600px;
            color: #ffffff;
        }
        
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .close:hover {
            color: #ffffff;
        }
        
        .entry-exit-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        
        .price-size-row {
            display: grid;
            grid-template-columns: 1fr 1fr auto;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
        }
        
        /* Spreadsheet-like grid styling */
        .trades-grid-container {
            overflow-x: auto;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .trades-grid {
            width: fit-content;
            border-collapse: collapse;
            font-size: 12px;
            background: transparent;
            table-layout: auto;
        }
        
        .trades-grid th {
            background: transparent;
            color: #ffffff;
            padding: 4px 8px;
            font-size: 12px;
            text-align: left;
            border-bottom: 1.5px solid #ffffff;
            position: sticky;
            top: 0;
            z-index: 10;
            height: 25px;
        }
        
        .trades-grid td {
            padding: 4px 8px;
            background: #000000;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            color: #00d4ff;
            font-size: 12px;
        }
        
        .trades-grid tr:hover {
            background: rgba(128, 128, 128, 0.2);
        }
        
        .trades-grid input,
        .trades-grid select {
            height: 100%;
            border: none;
            background: transparent;
            color: #00d4ff;
            font-size: 13px;
            padding: 4px;
            box-sizing: border-box;
        }
        
        .trades-grid select {
            font-size: 13px;
        }
        
        .trades-grid input:focus,
        .trades-grid select:focus {
            outline: 2px solid #007bff;
            background: #2a2a2a;
        }
        
        .grid-btn {
            padding: 2px 6px;
            font-size: 8px;
            margin: 1px;
        }
        
        /* Modal styling for trade entry */
        .trade-basic-info {
            margin-bottom: 20px;
        }
        
        .basic-info-row {
            display: flex;
            gap: 2px;
            align-items: end;
        }
        
        .form-group-modal {
            display: flex;
            flex-direction: column;
        }
        
        .form-group-modal label {
            color: #ffffff;
            margin-bottom: 2px;
            font-size: 12px;
            font-weight: normal;
        }
        
        .positions-section h4 {
            color: #ffffff;
            font-size: 1.17em;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .basic-info-table {
            width: 600px;
            border-collapse: collapse;
            font-size: 12px;
            background: transparent;
            margin-bottom: 10px;
        }
        
        .basic-info-table th {
            background: #1a1a1a;
            color: #ffffff;
            padding: 4px 8px;
            font-size: 12px;
            text-align: left;
            border-bottom: 1.5px solid #ffffff;
        }
        
        .basic-info-table td {
            padding: 0;
            background: #000000;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .basic-info-table tr:hover {
            background: rgba(128, 128, 128, 0.2);
        }
        
        .basic-info-table .total-pnl-display {
            background: #000000 !important;
            width: 100%;
            height: 100%;
            padding: 4px 8px;
            box-sizing: border-box;
            display: block;
            min-width: 70px;
            text-align: center;
        }
        
        .basic-info-table input,
        .basic-info-table select {
            width: 100%;
            height: 100%;
            border: none;
            background: #000000 !important;
            color: #00d4ff !important;
            font-size: 12px;
            padding: 4px 8px;
            box-sizing: border-box;
            -webkit-appearance: none !important;
            -moz-appearance: none !important;
            appearance: none !important;
        }
        
        .basic-info-table select option {
            background: #000000 !important;
            color: #00d4ff !important;
        }
        
        .basic-info-table input:hover,
        .basic-info-table select:hover {
            background: rgba(128, 128, 128, 0.2) !important;
        }
        
        .basic-info-table input:focus,
        .basic-info-table select:focus {
            background: #000000 !important;
            outline: 1px solid #ffffff !important;
            border-radius: 0px !important;
            border: none !important;
        }
        
        .form-group-modal input,
        .form-group-modal select,
        .modal-trade-type,
        .modal-instrument {
            padding: 4px;
            border: none;
            border-radius: 0px;
            background-color: #000000 !important;
            background: #000000 !important;
            color: #00d4ff !important;
            font-size: 12px;
            box-sizing: border-box;
        }
        
        .form-group-modal input:hover,
        .form-group-modal select:hover,
        .modal-trade-type:hover,
        .modal-instrument:hover {
            background-color: #00d4ff33 !important;
            background: #00d4ff33 !important;
        }
        
        .form-group-modal input:focus,
        .form-group-modal select:focus,
        .modal-trade-type:focus,
        .modal-instrument:focus {
            outline: none;
            border-radius: 0px;
            background-color: #000000 !important;
            background: #000000 !important;
        }
        
        /* Force black background on all select elements in modal */
        select.modal-trade-type,
        .modal-trade-type,
        #instrumentLines select,
        .basic-info-row select {
            background-color: #000000 !important;
            background: #000000 !important;
            -webkit-appearance: none !important;
            -moz-appearance: none !important;
            appearance: none !important;
            color: #00d4ff !important;
        }
        
        /* Target option elements specifically */
        select.modal-trade-type option,
        .modal-trade-type option,
        #instrumentLines select option,
        .basic-info-row select option {
            background-color: #000000 !important;
            background: #000000 !important;
            color: #00d4ff !important;
        }
        
        /* Additional aggressive targeting */
        .form-group-modal select,
        .form-group-modal select:focus,
        .form-group-modal select:hover,
        .form-group-modal select:active {
            background-color: #000000 !important;
            background: #000000 !important;
            color: #00d4ff !important;
        }
        
        .positions-section {
            margin-top: 20px;
        }
        
        .positions-table-container {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 10px;
        }
        
        .positions-table {
            width: 300px;
            border-collapse: collapse;
            font-size: 12px;
            background: transparent;
        }
        
        .positions-table th {
            background: #1a1a1a;
            color: #ffffff;
            padding: 4px 8px;
            font-size: 12px;
            text-align: left;
            border-bottom: 1.5px solid #ffffff;
        }
        
        .positions-table td {
            padding: 0;
            background: #000000;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .positions-table tr:hover {
            background: rgba(128, 128, 128, 0.2);
        }
        
        .positions-table input,
        .positions-table select {
            width: 100%;
            height: 100%;
            border: none;
            background: #000000 !important;
            color: #00d4ff !important;
            font-size: 12px;
            padding: 4px 8px;
            box-sizing: border-box;
            -webkit-appearance: none !important;
            -moz-appearance: none !important;
            appearance: none !important;
        }
        
        .positions-table select option {
            background: #000000 !important;
            color: #00d4ff !important;
        }
        
        .positions-table input[type="number"] {
            width: 80px;
            text-align: left;
            background: transparent !important;
        }
        
        .positions-table input:hover,
        .positions-table select:hover {
            background: rgba(128, 128, 128, 0.2) !important;
        }
        
        .positions-table input:focus,
        .positions-table select:focus,
        .positions-table select:active {
            background: #000000 !important;
            outline: 1px solid #ffffff !important;
            border-radius: 0px !important;
            border: none !important;
        }
        
        .positions-table input:focus {
            background: transparent !important;
            outline: 1px solid #ffffff !important;
            border-radius: 0px !important;
            border: none !important;
        }
        
        .positions-table input::-webkit-outer-spin-button,
        .positions-table input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        
        .positions-table input[type=number] {
            -moz-appearance: textfield;
        }
        
        .position-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .trades-grid tbody tr {
            cursor: pointer;
        }
        
        .trades-grid tbody tr:hover {
            background: #2a2a2a;
        }
        
        /* Group styling for collapsible trade groups */
        .trade-group-header {
            background: #1a1a1a !important;
            border-left: 3px solid #00d4ff;
        }
        
        .trade-group-header td {
            font-weight: bold;
            background: #1a1a1a !important;
            padding: 4px 8px !important;
            font-size: 12px !important;
            text-align: left !important;
        }
        
        
        .trade-group-header:hover {
            background: #2a2a2a !important;
        }
        
        .trade-group-header .group-arrow {
            font-size: 12px;
            color: #00d4ff;
            margin-right: 8px;
            transition: transform 0.2s ease;
            display: inline-block;
        }
        
        .trade-group-header .group-arrow.collapsed {
            transform: rotate(-90deg);
        }
        
        .trade-group-member {
            border-left: 3px solid #444;
        }
        
        .trade-group-member td {
            padding-left: 20px !important;
        }
        
        .trade-group-member.hidden {
            display: none;
        }
        
        .group-summary {
            color: #888;
            font-size: 11px;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Navigation -->
        <div class="navigation">
            <a href="/" class="nav-link">Charts</a>
            <a href="/regression" class="nav-link">Regression</a>
            <a href="/trading" class="nav-link active">Trading</a>
        </div>

        <!-- Chart controls above trading grid (matching charts page format) -->
        <div class="chart-controls" style="display: flex; justify-content: space-between; align-items: center;">
            <button id="load-pnl-btn" class="load-realtime-button" style="background: #cc7a00;">
                <span class="pnl-button-text">Load Real Time Data + P&L</span>
                <span class="pnl-loading-spinner" style="display: none;">‚ü≥</span>
            </button>
            
            <!-- P&L Timestamp Display -->
            <div id="pnlTimestamp" style="color: #00d4ff; font-size: 12px; display: none;">
                P&L as of: <span id="timestampValue">--</span>
            </div>
        </div>

        <div class="trading-container">
        <!-- Trades Panel (Top) -->
        <div class="trading-panel trades-panel" style="border: none;">
            <div class="trades-grid-container">
                <table class="trades-grid" id="tradesGrid">
                    <thead>
                        <tr>
                            <th style="width: 90px;">Type</th>
                            <th style="width: 150px;">Identifier</th>
                            <th style="width: 200px;">Expression</th>
                            <th style="width: 80px;">Avg Entry</th>
                            <th style="width: 80px;">Total 01</th>
                            <th style="width: 80px;">P&L</th>
                            <th style="width: 80px;">1d PnL</th>
                            <th style="width: 80px;">Col 8</th>
                            <th style="width: 80px;">Col 9</th>
                            <th style="width: 80px;">Col 10</th>
                            <th style="width: 80px;">Col 11</th>
                            <th style="width: 80px;">Col 12</th>
                            <th style="width: 80px;">Col 13</th>
                            <th style="width: 80px;">Col 14</th>
                            <th style="width: 60px;"></th>
                        </tr>
                    </thead>
                    <tbody id="tradesGridBody">
                        <!-- Completed trades will be displayed here -->
                    </tbody>
                </table>
            </div>
            
            <div style="margin-top: 10px;">
                <button type="button" class="btn btn-primary" onclick="addNewRow()">+ Row</button>
            </div>
        </div>


        <!-- Charts Row (Bottom) -->
        <div class="charts-row">
            <!-- Portfolio PnL Chart (Bottom Left) -->
            <div class="trading-panel portfolio-chart">
                <div class="chart-container" id="portfolioChart"></div>
            </div>

            <!-- Instrument Chart (Bottom Right) -->
            <div class="trading-panel instrument-chart">
                <div class="chart-container" id="instrumentChart"></div>
            </div>
        </div>
        </div>
    </div>

    <!-- Trade Entry Modal -->
    <div id="tradeModal" class="modal">
        <div class="modal-content" style="max-width: 800px; width: 90%;">
            <span class="close" onclick="closeTradeModal()">&times;</span>
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px; position: relative;">
                <input type="text" id="modalTitle" placeholder="Enter trade identifier..." style="background: transparent; border: none; color: #ffffff; font-size: 1.17em; font-weight: bold; flex: 1; margin: 0; padding: 5px; border-bottom: 1px solid #444;">
                <div style="display: flex; align-items: center; gap: 10px; margin-left: 20px;">
                    <label style="color: #ffffff; font-size: 12px; white-space: nowrap;">Group ID:</label>
                    <input type="text" id="singleGroupId" placeholder="Group ID" style="background: transparent; border: none; color: #00d4ff; font-size: 12px; padding: 5px; border-bottom: 1px solid #444; width: 120px;">
                </div>
                <div id="errorBanner" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: #dc3545; color: white; padding: 5px 10px; font-size: 12px; border-radius: 0 0 4px 4px; z-index: 1000;"></div>
            </div>
            
            <style>
            #modalTitle::placeholder {
                color: #888888;
                opacity: 1;
            }
            
            .error-highlight {
                border: 2px solid #dc3545 !important;
                background: rgba(220, 53, 69, 0.1) !important;
            }
            
            .error-highlight:focus {
                outline: 2px solid #dc3545 !important;
            }
            </style>
            
            <div id="modalContent">
                <!-- Basic Trade Info -->
                <div class="trade-basic-info">
                    <table class="basic-info-table" id="basicInfoTable">
                        <thead>
                            <tr>
                                <th style="width: 80px;">Type</th>
                                <th style="width: 400px;">Expression</th>
                                <th style="width: 80px;">Live Rate</th>
                                <th style="width: 90px;">Total P&L</th>
                            </tr>
                        </thead>
                        <tbody id="basicInfoTableBody">
                            <tr>
                                <td>
                    <select class="modal-trade-type" id="singleTradeType" onchange="handleTypeChange(this)" oninput="handleTypeChange(this)">
                        <option value="">Select Type</option>
                        <option value="swap">Swap</option>
                        <option value="future">Future/FX</option>
                        <option value="efp">EFP</option>
                    </select>
                                </td>
                                <td>
                                    <input type="text" class="modal-instrument" id="singleInstrument" placeholder="e.g., aud.5y5y" onchange="handleInstrumentChange(this)" oninput="handleInstrumentChange(this)" onblur="handleInstrumentChange(this)">
                                </td>
                                <td>
                                    <span class="live-rate-display" id="singleLiveRate" style="color: #cccccc; padding: 4px 8px; display: inline-block; min-width: 75px; text-align: center;">--</span>
                                </td>
                                <td>
                                    <span class="total-pnl-display" id="singleTotalPnL" style="color: #cccccc; padding: 4px 8px; display: inline-block; min-width: 70px; text-align: center;">--</span>
                                </td>
                            </tr>
                        <!-- Secondary row for EFP futures leg (hidden by default) -->
                        <tr id="secondaryInstrumentRow" style="display: none;">
                            <td>
                                <span style="color: #888; padding: 4px 8px; font-size: 11px;">Futures</span>
                            </td>
                            <td>
                                <input type="text" class="modal-instrument-secondary" id="secondaryInstrument" placeholder="e.g., xmz5 comdty-ymz5 comdty" onchange="handleInstrumentChange(this)" oninput="handleInstrumentChange(this)" onblur="handleInstrumentChange(this)">
                            </td>
                            <td>
                                <span class="live-rate-display" id="secondaryLiveRate" style="color: #cccccc; padding: 4px 8px; display: inline-block; min-width: 75px; text-align: center;">--</span>
                            </td>
                            <td>
                                <span class="total-pnl-display" style="color: #cccccc; padding: 4px 8px; display: inline-block; min-width: 70px; text-align: center;">--</span>
                            </td>
                        </tr>
                        <!-- Third row for EFP total P&L (hidden by default) -->
                        <tr id="efpTotalRow" style="display: none;">
                            <td>
                                <span style="color: #00d4ff; padding: 4px 8px; font-size: 11px; font-weight: bold;">Total</span>
                            </td>
                            <td>
                                <span style="color: #888; padding: 4px 8px; font-size: 11px;">Combined P&L</span>
                            </td>
                            <td>
                                <span style="color: #cccccc; padding: 4px 8px; display: inline-block; min-width: 60px; text-align: center;">--</span>
                            </td>
                            <td>
                                <span class="total-pnl-display" id="efpTotalPnL" style="color: #cccccc; padding: 4px 8px; display: inline-block; min-width: 70px; text-align: center;">--</span>
                            </td>
                        </tr>
                        </tbody>
                    </table>
                </div>
                
                <!-- Positions Table (Primary - for Swap leg) -->
                <div class="positions-section" id="primaryPositionsSection">
                    <h4 id="primaryPositionsTitle">Positions</h4>
                    <div class="positions-table-container">
                        <table class="positions-table" id="positionsTable">
                            <thead>
                                <tr>
                                    <th>Price</th>
                                    <th id="primarySizeHeader">01</th>
                                    <th>Insertion Date</th>
                                    <th>P&L</th>
                                </tr>
                            </thead>
                            <tbody id="positionsTableBody">
                                <!-- Positions will be added here -->
                            </tbody>
                        </table>
                    </div>
                    
                    <div class="position-buttons">
                        <button type="button" class="btn btn-secondary" onclick="addPosition('primary')">+ Add Position</button>
                    </div>
                </div>
                
                <!-- Secondary Positions Table (for EFP Futures leg) -->
                <div class="positions-section" id="secondaryPositionsSection" style="display: none; margin-top: 20px;">
                    <h4>Futures Positions</h4>
                    <div class="positions-table-container">
                        <table class="positions-table" id="secondaryPositionsTable">
                            <thead>
                                <tr>
                                    <th>Price</th>
                                    <th id="secondarySizeHeader">Lots</th>
                                    <th>Insertion Date</th>
                                    <th>P&L</th>
                                </tr>
                            </thead>
                            <tbody id="secondaryPositionsTableBody">
                                <!-- Secondary positions will be added here -->
                            </tbody>
                        </table>
                    </div>
                    
                    <div class="position-buttons">
                        <button type="button" class="btn btn-secondary" onclick="addPosition('secondary')">+ Add Position</button>
                    </div>
                </div>
                
                <div style="margin-top: 20px; text-align: right;">
                    <button type="button" class="btn btn-primary" onclick="saveTrade()">Save Trade</button>
                    <button type="button" class="btn btn-secondary" onclick="closeTradeModal()">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        let portfolio = {};
        let currentTradeId = null;
        
        // Initialize empty portfolio chart (left) - feint aqua gridlines, transparent bg, white text
        Plotly.newPlot('portfolioChart', [], {
            plot_bgcolor: 'rgba(0,0,0,0)',
            paper_bgcolor: 'rgba(0,0,0,0)',
            font: { color: '#ffffff' },
            xaxis: { 
                gridcolor: 'rgba(0, 212, 255, 0.15)',
                color: '#ffffff',
                dtick: 'M1',
                tickformat: '%m/%d/%y',
                showline: false,
                zeroline: false
            },
                        yaxis: { 
                            gridcolor: 'rgba(0, 212, 255, 0.15)', 
                            color: '#ffffff',
                            showline: true,
                            linecolor: '#ffffff',
                            linewidth: 1,
                            zeroline: false
                        },
            margin: { l: 50, r: 45, t: 45, b: 45, pad: 0 }
        });
        
        // Initialize empty instrument chart (right)
        Plotly.newPlot('instrumentChart', [], {
            plot_bgcolor: 'rgba(0,0,0,0)',
            paper_bgcolor: 'rgba(0,0,0,0)',
            font: { color: '#ffffff' },
            xaxis: { 
                gridcolor: 'rgba(0, 212, 255, 0.15)',
                color: '#ffffff',
                dtick: 'M1',
                tickformat: '%b',
                showline: false,
                zeroline: false
            },
            yaxis: { 
                gridcolor: 'rgba(0, 212, 255, 0.15)',
                color: '#ffffff',
                showline: false,
                zeroline: false
            },
            margin: { l: 45, r: 45, t: 45, b: 45, pad: 0 }
        });
        
        function addTrade() {
            const form = document.getElementById('tradeForm');
            const formData = new FormData(form);
            
            const tradeData = {
                type: formData.get('tradeType'),
                name: formData.get('tradeName') || `Trade ${Date.now()}`,
                primary_instrument: formData.get('primaryInstrument'),
                secondary_instrument: formData.get('secondaryInstrument'),
                entry_price: parseFloat(formData.get('entryPrice')) || 0,
                entry_size: parseFloat(formData.get('entrySize')) || 0
            };
            
            if (!tradeData.type || !tradeData.primary_instrument) {
                alert('Please fill in required fields');
                return;
            }
            
            fetch('/add_trade', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(tradeData)
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    clearForm();
                    loadTrades();
                    updateCharts();
                } else {
                    alert('Error adding trade: ' + (data.error || 'Unknown error'));
                }
            })
            .catch(error => {
                console.error('Error:', error);
                alert('Error adding trade');
            });
        }
        
        function clearForm() {
            document.getElementById('tradeForm').reset();
        }
        
        function loadTrades() {
            fetch('/get_trades')
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    displayTrades(data.trades);
                }
            })
            .catch(error => console.error('Error loading trades:', error));
        }
        
        function displayTrades(trades) {
            const tradesList = document.getElementById('tradesList');
            tradesList.innerHTML = '';
            
            Object.values(trades).forEach(trade => {
                const tradeDiv = document.createElement('div');
                tradeDiv.className = 'trade-item';
                
                const pnl = trade.pnl || {};
                const pnlColor = (pnl.total_pnl || 0) >= 0 ? '#51cf66' : '#ff6b6b';
                
                tradeDiv.innerHTML = `
                    <h4>${trade.trade_id}</h4>
                    <div class="trade-details">
                        <div><strong>Type:</strong> ${trade.typology}</div>
                        <div><strong>Instrument:</strong> ${trade.instrument_details}</div>
                        <div style="color: ${pnlColor}"><strong>PnL:</strong> ${(pnl.total_pnl || 0).toFixed(2)}</div>
                        <div><strong>Avg Entry:</strong> ${(trade.weighted_avg_entry || 0).toFixed(3)}</div>
                        <div><strong>Live Price:</strong> ${(trade.live_price || 0).toFixed(3)}</div>
                        <div><button class="btn btn-secondary" onclick="openTradeDetails('${trade.trade_id}')">Details</button></div>
                    </div>
                `;
                
                tradesList.appendChild(tradeDiv);
            });
        }
        
        function openTradeDetails(tradeId) {
            currentTradeId = tradeId;
            
            fetch(`/get_trade_details/${tradeId}`)
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    displayTradeModal(data.trade);
                } else {
                    alert('Error loading trade details: ' + (data.error || 'Unknown error'));
                }
            })
            .catch(error => {
                console.error('Error:', error);
                alert('Error loading trade details');
            });
        }
        
        function displayTradeModal(trade) {
            document.getElementById('modalTitle').textContent = `Trade Details: ${trade.trade_id}`;
            
            // This function is no longer used in the simplified interface
            // All trade editing is handled through openTradeModal and loadTradeForEditing
            
            document.getElementById('tradeModal').style.display = 'block';
        }
        
        function closeTradeModal() {
            console.log('üö™ Closing modal...');
            
            // RESTORE PORTFOLIO: If we have a backup and changes weren't saved via saveTrade(), restore it
            if (portfolioBackup) {
                console.log('üîÑ Restoring portfolio from backup...');
                
                // Send restore request to backend
                fetch('/restore_portfolio', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(portfolioBackup)
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        console.log('‚úÖ Portfolio restored successfully');
                        // Reload trades from restored portfolio
                        loadTradesFromBackend();
                    } else {
                        console.error('‚ùå Failed to restore portfolio:', data.error);
                    }
                })
                .catch(error => {
                    console.error('‚ùå Error restoring portfolio:', error);
                })
                .finally(() => {
                    // Clear backup after restoration attempt
                    portfolioBackup = null;
                });
            }
            
            document.getElementById('tradeModal').style.display = 'none';
            currentTradeId = null;
            hideErrorBanner();
        }
        
        function showErrorBanner(message) {
            const errorBanner = document.getElementById('errorBanner');
            errorBanner.textContent = message;
            errorBanner.style.display = 'block';
        }
        
        function hideErrorBanner() {
            const errorBanner = document.getElementById('errorBanner');
            errorBanner.style.display = 'none';
            
            // Remove error highlighting from all fields
            document.querySelectorAll('.error-highlight').forEach(element => {
                element.classList.remove('error-highlight');
            });
        }
        
        function validateTradeForm() {
            hideErrorBanner();
            
            const errors = [];
            const errorFields = [];
            
            // Validate trade identifier
            const tradeIdentifier = document.getElementById('modalTitle').value.trim();
            if (!tradeIdentifier) {
                errors.push('Trade identifier is required');
                errorFields.push(document.getElementById('modalTitle'));
            }
            
            // Validate basic info rows
            const basicInfoRows = document.getElementById('basicInfoTableBody').querySelectorAll('tr');
            let hasValidBasicInfo = false;
            
            basicInfoRows.forEach((row, index) => {
                const tradeTypeSelect = row.querySelector('select.modal-trade-type');
                const instrumentInput = row.querySelector('input.modal-instrument');
                
                const tradeType = tradeTypeSelect ? tradeTypeSelect.value.trim() : '';
                const instrument = instrumentInput ? instrumentInput.value.trim() : '';
                
                // Check if row has any data
                const hasAnyData = tradeType || instrument;
                
                if (hasAnyData) {
                    // If row has any data, both fields must be filled
                    if (!tradeType) {
                        errors.push(`Row ${index + 1}: Type is required when instrument is specified`);
                        if (tradeTypeSelect) errorFields.push(tradeTypeSelect);
                    }
                    if (!instrument) {
                        errors.push(`Row ${index + 1}: Instrument is required when type is specified`);
                        if (instrumentInput) errorFields.push(instrumentInput);
                    }
                    
                    // If both fields are filled, mark as valid
                    if (tradeType && instrument) {
                        hasValidBasicInfo = true;
                    }
                }
            });
            
            if (!hasValidBasicInfo) {
                errors.push('At least one complete Type and Instrument pair is required');
            }
            
            // Validate positions
            const positionRows = document.getElementById('positionsTableBody').querySelectorAll('tr');
            let hasValidPosition = false;
            
            positionRows.forEach((row, index) => {
                const priceInput = row.querySelector('[data-position-price]');
                const sizeInput = row.querySelector('[data-position-size]');
                
                const price = priceInput ? priceInput.value.trim() : '';
                const size = sizeInput ? sizeInput.value.trim() : '';
                
                // Check if row has any data
                const hasAnyData = price || size;
                
                if (hasAnyData) {
                    // If row has any data, both fields must be filled
                    if (!price) {
                        errors.push(`Position ${index + 1}: Price is required`);
                        if (priceInput) errorFields.push(priceInput);
                    }
                    if (!size) {
                        errors.push(`Position ${index + 1}: Size is required`);
                        if (sizeInput) errorFields.push(sizeInput);
                    }
                    
                    // Validate numeric values
                    if (price && isNaN(parseFloat(price))) {
                        errors.push(`Position ${index + 1}: Price must be a valid number`);
                        if (priceInput) errorFields.push(priceInput);
                    }
                    if (size && isNaN(parseFloat(size))) {
                        errors.push(`Position ${index + 1}: Size must be a valid number`);
                        if (sizeInput) errorFields.push(sizeInput);
                    }
                    
                    // If both fields are valid, mark as valid position
                    if (price && size && !isNaN(parseFloat(price)) && !isNaN(parseFloat(size))) {
                        hasValidPosition = true;
                    }
                }
            });
            
            if (!hasValidPosition) {
                errors.push('At least one complete position (price and size) is required');
            }
            
            // Show errors if any
            if (errors.length > 0) {
                // Highlight error fields
                errorFields.forEach(field => {
                    field.classList.add('error-highlight');
                });
                
                // Show first error in banner
                showErrorBanner(errors[0]);
                return false;
            }
            
            return true;
        }
        
        // These functions are no longer used in the simplified interface
        // All position management is handled through addPosition() and removePosition()
        
        function saveTradeDetails() {
            // This function is no longer used in the simplified interface
            // All trade saving is handled through saveTrade()
            console.log('‚ö†Ô∏è saveTradeDetails is deprecated, use saveTrade() instead');
        }
        
        function deleteTrade() {
            if (!currentTradeId) return;
            
            if (confirm('Are you sure you want to delete this trade?')) {
                fetch(`/delete_trade/${currentTradeId}`, { method: 'DELETE' })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        closeTradeModal();
                        loadTrades();
                        updateCharts();
                    } else {
                        alert('Error deleting trade: ' + (data.error || 'Unknown error'));
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert('Error deleting trade');
                });
            }
        }
        
        function updateRegressionTable() {
            const instruments = [
                document.getElementById('regInstrument1').value,
                document.getElementById('regInstrument2').value,
                document.getElementById('regInstrument3').value
            ].filter(inst => inst.trim() !== '');
            
            if (instruments.length === 0) {
                alert('Please enter at least one instrument');
                return;
            }
            
            // Get current portfolio instrument (for now, use first trade's instrument)
            fetch('/get_trades')
            .then(response => response.json())
            .then(data => {
                if (data.success && Object.keys(data.trades).length > 0) {
                    const firstTrade = Object.values(data.trades)[0];
                    const yInstrument = firstTrade.instrument_details;
                    
                    return fetch('/run_trade_regression', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            y_instrument: yInstrument,
                            x_instruments: instruments
                        })
                    });
                } else {
                    throw new Error('No trades available for regression');
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    updateRegressionDisplay(data.results, instruments);
                } else {
                    alert('Error running regression: ' + (data.error || 'Unknown error'));
                }
            })
            .catch(error => {
                console.error('Error:', error);
                alert('Error running regression: ' + error.message);
            });
        }
        
        function updateRegressionDisplay(results, instruments) {
            instruments.forEach((instrument, instIndex) => {
                [1, 2, 3].forEach(months => {
                    const result = results[instrument];
                    if (result && result[months] && result[months].regression) {
                        const reg = result[months].regression;
                        document.getElementById(`r2_${instIndex + 1}_${months}`).textContent = 
                            reg.r_squared ? reg.r_squared.toFixed(3) : '--';
                        document.getElementById(`beta_${instIndex + 1}_${months}`).textContent = 
                            reg.beta ? reg.beta.toFixed(3) : '--';
                    } else {
                        document.getElementById(`r2_${instIndex + 1}_${months}`).textContent = '--';
                        document.getElementById(`beta_${instIndex + 1}_${months}`).textContent = '--';
                    }
                });
            });
        }
        
        function updateCharts() {
            // Portfolio chart (bottom left) will remain empty until user clicks a trade's PnL button
            // Only update instrument chart (bottom right) as placeholder
            const instrumentTrace = {
                x: [],
                y: [],
                type: 'scatter',
                mode: 'lines',
                name: 'Instrument Performance',
                line: { color: '#51cf66' }
            };
            
            Plotly.newPlot('instrumentChart', [instrumentTrace], {
                plot_bgcolor: '#1e1e1e',
                paper_bgcolor: '#1e1e1e',
                font: { color: '#ffffff' },
                xaxis: { gridcolor: '#2a4a5a', color: '#ffffff', title: 'Date', dtick: 'M1', tickformat: '%b' },
                yaxis: { gridcolor: '#2a4a5a', color: '#ffffff', title: 'Price' },
                margin: { l: 45, r: 45, t: 45, b: 45, pad: 0 }
            });
        }
        
        // New popup-based trading system
        let storedTrades = [];
        let positionCounter = 0;
        let cachedFuturesData = null; // Cache futures tick data to avoid repeated API calls
        
        // Temporary trade object for modal editing
        let tempTradeObject = null;
        
        // Track if current trade is temporary (new) or existing
        let isTemporaryTrade = false;
        
        // Store original trade state for reverting edits
        let originalTradeState = null;
        
        // Store complete portfolio backup when modal opens
        let portfolioBackup = null;
        
        // Initialize temporary trade object
        function initializeTempTrade() {
            tempTradeObject = {
                trade_id: '',
                typology: [],
                instrument_details: [],
                instrument_details_secondary: [],
                positions: {
                    primary: [],
                    secondary: []
                },
                live_rates: {
                    primary: null,
                    secondary: null
                }
            };
            console.log('üÜï Initialized temp trade object:', tempTradeObject);
        }
        
        // Update trade basic info (type and instrument)
        function updateTradeInfo(field, value, isSecondary = false) {
            if (!tempTradeObject) {
                console.error('‚ùå Temp trade object not initialized');
                return;
            }
            
            if (field === 'trade_id') {
                tempTradeObject.trade_id = value;
            } else if (field === 'type') {
                if (isSecondary) {
                    // For secondary (always futures in EFP)
                    if (tempTradeObject.typology.length < 2) {
                        tempTradeObject.typology.push(value);
                    } else {
                        tempTradeObject.typology[1] = value;
                    }
                } else {
                    // For primary
                    if (tempTradeObject.typology.length === 0) {
                        tempTradeObject.typology.push(value);
                    } else {
                        tempTradeObject.typology[0] = value;
                    }
                }
            } else if (field === 'instrument') {
                if (isSecondary) {
                    if (tempTradeObject.instrument_details_secondary.length === 0) {
                        tempTradeObject.instrument_details_secondary.push(value);
                    } else {
                        tempTradeObject.instrument_details_secondary[0] = value;
                    }
                } else {
                    if (tempTradeObject.instrument_details.length === 0) {
                        tempTradeObject.instrument_details.push(value);
                    } else {
                        tempTradeObject.instrument_details[0] = value;
                    }
                }
            } else if (field === 'live_rate') {
                if (isSecondary) {
                    tempTradeObject.live_rates.secondary = value;
                } else {
                    tempTradeObject.live_rates.primary = value;
                }
            }
            
            console.log(`‚úèÔ∏è Updated trade info: ${field} = ${value} (secondary: ${isSecondary})`, tempTradeObject);
        }
        
        // Update or add a position in the temp trade object
        function updateTradePosition(positionIndex, price, size, tableType = 'primary') {
            if (!tempTradeObject) {
                console.error('‚ùå Temp trade object not initialized');
                return;
            }
            
            const positionArray = tableType === 'secondary' 
                ? tempTradeObject.positions.secondary 
                : tempTradeObject.positions.primary;
            
            // Ensure position exists at index
            while (positionArray.length <= positionIndex) {
                positionArray.push({ price: null, size: null });
            }
            
            // Update position
            if (price !== null && price !== undefined) {
                positionArray[positionIndex].price = price;
            }
            if (size !== null && size !== undefined) {
                positionArray[positionIndex].size = size;
            }
            
            console.log(`‚úèÔ∏è Updated ${tableType} position ${positionIndex}:`, positionArray[positionIndex], tempTradeObject);
        }
        
        // Remove a position from temp trade object
        function removeTradePosition(positionIndex, tableType = 'primary') {
            if (!tempTradeObject) return;
            
            const positionArray = tableType === 'secondary' 
                ? tempTradeObject.positions.secondary 
                : tempTradeObject.positions.primary;
            
            if (positionIndex < positionArray.length) {
                positionArray.splice(positionIndex, 1);
                console.log(`üóëÔ∏è Removed ${tableType} position at index ${positionIndex}`);
            }
        }
        
        // Open popup for new trade entry
        function addNewRow() {
            openTradeModal();
        }
        
        function clearLastRow() {
            // Clear the last trade from the display
            const tbody = document.getElementById('tradesGridBody');
            const rows = tbody.querySelectorAll('tr');
            if (rows.length > 0) {
                const lastRow = rows[rows.length - 1];
                lastRow.remove();
                storedTrades.pop();
            }
        }
        
        function undoLastClear() {
            // Re-add the last cleared trade
            if (storedTrades.length > 0) {
                displayTradesInGrid();
            }
        }
        
        function openTradeModal(tradeId = null) {
            console.log('üîÑ Opening modal:', tradeId ? `Edit ${tradeId}` : 'New trade');
            
            // CRITICAL: Reset position counter to 0 every time we open a modal
            positionCounter = 0;
            console.log('üîÑ Reset position counter to 0 on modal open');
            
            // Clear any previous errors
            hideErrorBanner();
            
            // BACKUP PORTFOLIO: Store complete portfolio state before any changes
            console.log('üíæ Creating portfolio backup before opening modal...');
            fetch('/get_trades')
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    portfolioBackup = JSON.parse(JSON.stringify(data));
                    console.log('‚úÖ Portfolio backup created:', Object.keys(portfolioBackup.trades || {}).length, 'trades');
                    
                    // IMPORTANT: Only proceed after backup is created
                    proceedWithModalOpening(tradeId);
                } else {
                    console.error('‚ùå Failed to backup portfolio:', data.error);
                    alert('Error creating portfolio backup. Please try again.');
                }
            })
            .catch(error => {
                console.error('‚ùå Error creating portfolio backup:', error);
                alert('Error creating portfolio backup: ' + error.message);
            });
        }
        
        function proceedWithModalOpening(tradeId) {
            console.log('üöÄ Proceeding with modal opening after backup created');
            
            // Show the modal
            document.getElementById('tradeModal').style.display = 'block';
            
            if (tradeId) {
                // Editing existing trade
                currentTradeId = tradeId;
                loadTradeForEditing(tradeId);
            } else {
                // Creating new trade - just build blank modal WITHOUT creating backend entry
                console.log('üÜï Building blank modal for new trade (no backend call)');
                currentTradeId = null; // No trade ID yet
                buildBlankModal();
            }
        }
        
        function buildBlankModal() {
            console.log('üÜï Building blank modal for trade:', currentTradeId);
            
            // Initialize temp trade object
            initializeTempTrade();
            
            // Clear and rebuild everything
            clearModalForm();
            
            // CRITICAL: Reset position counter to 0 for new trade
            positionCounter = 0;
            console.log('üîÑ Reset position counter to 0');
            
            // Don't pre-fill the modal title - user must enter their own ID
            // (The auto-generated datetime ID is stored in backend for reference only)
            document.getElementById('modalTitle').value = '';
            
            // Set up listeners without automatically adding a position
            setTimeout(() => {
                setupAutoUpdateListeners();
                attachInputListeners();
            }, 50);
        }
        
        // Attach input listeners to update temp trade object
        function attachInputListeners() {
            console.log('üîó Attaching input listeners to update temp trade object');
            
            // Trade ID listener
            const titleInput = document.getElementById('modalTitle');
            if (titleInput) {
                titleInput.addEventListener('input', function() {
                    updateTradeInfo('trade_id', this.value);
                });
            }
            
            // Primary type listener
            const primaryTypeSelect = document.getElementById('singleTradeType');
            if (primaryTypeSelect) {
                primaryTypeSelect.addEventListener('change', function() {
                    updateTradeInfo('type', this.value, false);
                });
            }
            
            // Primary instrument listener
            const primaryInstrument = document.getElementById('singleInstrument');
            if (primaryInstrument) {
                primaryInstrument.addEventListener('input', function() {
                    updateTradeInfo('instrument', this.value, false);
                    handleInstrumentChange(this);
                });
            }
            
            // Secondary instrument listener
            const secondaryInstrument = document.getElementById('secondaryInstrument');
            if (secondaryInstrument) {
                secondaryInstrument.addEventListener('input', function() {
                    updateTradeInfo('instrument', this.value, true);
                    updateTradeInfo('type', 'future', true); // Secondary is always future in EFP
                });
            }
            
            // Position input listeners - attach to existing positions
            attachPositionListeners();
        }
        
        // Function to attach listeners to position inputs
        function attachPositionListeners(tableType = 'both') {
            console.log('üîó Attaching position input listeners for:', tableType);
            
            if (tableType === 'both' || tableType === 'primary') {
                const primaryRows = document.querySelectorAll('#positionsTableBody tr');
                primaryRows.forEach((row, rowIndex) => {
                    // Price input
                    const priceInput = row.querySelector('[data-position-price]');
                    if (priceInput) {
                        priceInput.addEventListener('input', function() {
                            const price = parseFloat(this.value);
                            if (!isNaN(price)) {
                                updateTradePosition(rowIndex, price, null, 'primary');
                            }
                            // Trigger P&L calculation
                            handlePositionChange(this);
                        });
                    }
                    
                    // Size input(s) - can be multiple for futures
                    const sizeInputs = row.querySelectorAll('[data-position-size]');
                    if (sizeInputs.length > 1) {
                        // Multiple component sizes (futures)
                        const sizes = [];
                        sizeInputs.forEach((sizeInput, idx) => {
                            sizeInput.addEventListener('input', function() {
                                // Collect all sizes
                                const allSizes = [];
                                sizeInputs.forEach(input => {
                                    const val = parseFloat(input.value);
                                    allSizes.push(isNaN(val) ? null : val);
                                });
                                updateTradePosition(rowIndex, null, allSizes, 'primary');
                                // Trigger P&L calculation
                                handlePositionChange(priceInput);
                            });
                        });
                    } else if (sizeInputs.length === 1) {
                        // Single size input
                        sizeInputs[0].addEventListener('input', function() {
                            const size = parseFloat(this.value);
                            if (!isNaN(size)) {
                                updateTradePosition(rowIndex, null, size, 'primary');
                            }
                            // Trigger P&L calculation
                            handlePositionChange(priceInput);
                        });
                    }
                });
            }
            
            if (tableType === 'both' || tableType === 'secondary') {
                const secondaryRows = document.querySelectorAll('#secondaryPositionsTableBody tr');
                secondaryRows.forEach((row, rowIndex) => {
                    // Price input
                    const priceInput = row.querySelector('[data-position-price]');
                    if (priceInput) {
                        priceInput.addEventListener('input', function() {
                            const price = parseFloat(this.value);
                            if (!isNaN(price)) {
                                updateTradePosition(rowIndex, price, null, 'secondary');
                            }
                            // Trigger P&L calculation
                            handlePositionChange(this);
                        });
                    }
                    
                    // Size input(s) - can be multiple for futures
                    const sizeInputs = row.querySelectorAll('[data-position-size]');
                    if (sizeInputs.length > 1) {
                        // Multiple component sizes (futures)
                        sizeInputs.forEach((sizeInput, idx) => {
                            sizeInput.addEventListener('input', function() {
                                // Collect all sizes
                                const allSizes = [];
                                sizeInputs.forEach(input => {
                                    const val = parseFloat(input.value);
                                    allSizes.push(isNaN(val) ? null : val);
                                });
                                updateTradePosition(rowIndex, null, allSizes, 'secondary');
                                // Trigger P&L calculation
                                handlePositionChange(priceInput);
                            });
                        });
                    } else if (sizeInputs.length === 1) {
                        // Single size input
                        sizeInputs[0].addEventListener('input', function() {
                            const size = parseFloat(this.value);
                            if (!isNaN(size)) {
                                updateTradePosition(rowIndex, null, size, 'secondary');
                            }
                            // Trigger P&L calculation
                            handlePositionChange(priceInput);
                        });
                    }
                });
            }
            
            console.log('‚úÖ Position listeners attached');
        }
        
        // Wrapper function to ensure handleTypeChange is called
        function handleTypeChangeWrapper(event) {
            console.log('üîî Type select changed via event listener:', event.target.value);
            handleTypeChange(event.target);
        }
        
        // Function to attach type change listener (called after modal opens or clears)
        function attachTypeChangeListener() {
            const typeSelect = document.getElementById('singleTradeType');
            if (typeSelect) {
                // Remove any existing listeners first to avoid duplicates
                typeSelect.removeEventListener('change', handleTypeChangeWrapper);
                // Add fresh listener
                typeSelect.addEventListener('change', handleTypeChangeWrapper);
                console.log('‚úÖ Type select listener attached');
            } else {
                console.error('‚ùå Type select element not found');
            }
        }
        
        function clearModalForm() {
            console.log('üßπ Building fresh modal from scratch');
            
            // Get the tbody element
            const tbody = document.getElementById('basicInfoTableBody');
            
            // COMPLETELY clear and rebuild from scratch
            tbody.innerHTML = '';
            
            // Build PRIMARY row (with EFP type select)
            const primaryRow = document.createElement('tr');
            primaryRow.innerHTML = `
                <td>
                    <select class="modal-trade-type" id="singleTradeType" onchange="handleTypeChange(this)" oninput="handleTypeChange(this)">
                        <option value="">Select Type</option>
                        <option value="swap">Swap</option>
                        <option value="future">Future/FX</option>
                        <option value="efp">EFP</option>
                    </select>
                </td>
                <td>
                    <input type="text" class="modal-instrument" id="singleInstrument" placeholder="e.g., aud.5y5y" onchange="handleInstrumentChange(this)" oninput="handleInstrumentChange(this)" onblur="handleInstrumentChange(this)">
                </td>
                <td>
                    <span class="live-rate-display" id="singleLiveRate" style="color: #cccccc; padding: 4px 8px; display: inline-block; min-width: 75px; text-align: center;">--</span>
                </td>
                <td>
                    <span class="total-pnl-display" id="singleTotalPnL" style="color: #cccccc; padding: 4px 8px; display: inline-block; min-width: 70px; text-align: center;">--</span>
                </td>
            `;
            tbody.appendChild(primaryRow);
            
            // Build SECONDARY row (for EFP futures leg - HIDDEN by default)
            const secondaryRow = document.createElement('tr');
            secondaryRow.id = 'secondaryInstrumentRow';
            secondaryRow.style.display = 'none';
            secondaryRow.innerHTML = `
                <td>
                    <span style="color: #888; padding: 4px 8px; font-size: 11px;">Futures</span>
                </td>
                            <td>
                                <input type="text" class="modal-instrument-secondary" id="secondaryInstrument" placeholder="e.g., xmz5 comdty-ymz5 comdty" onchange="updateLiveRate(this)" oninput="updateLiveRate(this)" onblur="updateLiveRate(this)">
                            </td>
                            <td>
                                <span class="live-rate-display" id="secondaryLiveRate" style="color: #cccccc; padding: 4px 8px; display: inline-block; min-width: 75px; text-align: center;">--</span>
                            </td>
                <td>
                    <span class="total-pnl-display" style="color: #cccccc; padding: 4px 8px; display: inline-block; min-width: 70px; text-align: center;">--</span>
                </td>
            `;
            tbody.appendChild(secondaryRow);
            
            // Build TOTAL row (for EFP combined P&L - HIDDEN by default)
            const totalRow = document.createElement('tr');
            totalRow.id = 'efpTotalRow';
            totalRow.style.display = 'none';
            totalRow.style.background = 'transparent';
            totalRow.innerHTML = `
                <td style="background: transparent !important; border-bottom: none !important;">
                    <span style="color: #00d4ff; padding: 4px 8px; font-size: 11px; font-weight: bold;">Total</span>
                </td>
                            <td style="background: transparent !important; border-bottom: none !important;">
                                <span style="color: #888; padding: 4px 8px; font-size: 11px;">Spread</span>
                            </td>
                            <td style="background: transparent !important; border-bottom: none !important;">
                                <span class="spread-display" id="efpSpread" style="color: #cccccc; padding: 4px 8px; display: inline-block; min-width: 75px; text-align: center;">--</span>
                            </td>
                <td style="background: transparent !important; border-bottom: none !important;">
                    <span class="total-pnl-display" id="efpTotalPnL" style="background: transparent !important; color: #cccccc; padding: 4px 8px; display: inline-block; min-width: 70px; text-align: center;">--</span>
                </td>
            `;
            tbody.appendChild(totalRow);
            
            // Clear all positions
            const primaryPositionsBody = document.getElementById('positionsTableBody');
            if (primaryPositionsBody) {
                primaryPositionsBody.innerHTML = '';
            }
            
            const secondaryPositionsBody = document.getElementById('secondaryPositionsTableBody');
            if (secondaryPositionsBody) {
                secondaryPositionsBody.innerHTML = '';
            }
            
            // Hide secondary positions section
            const secondaryPositionsSection = document.getElementById('secondaryPositionsSection');
            if (secondaryPositionsSection) {
                secondaryPositionsSection.style.display = 'none';
            }
            
            // Reset primary positions title
            const primaryPositionsTitle = document.getElementById('primaryPositionsTitle');
            if (primaryPositionsTitle) {
                primaryPositionsTitle.textContent = 'Positions';
            }
            
            // Clear modal title
            document.getElementById('modalTitle').value = '';
            
            // CRITICAL FIX: Clear Group ID field
            const groupIdInput = document.getElementById('singleGroupId');
            if (groupIdInput) {
                groupIdInput.value = '';
                console.log('üßπ Cleared Group ID field');
            }
            
            // Reset position counter
            positionCounter = 0;
            
            // Clear cached futures data
            cachedFuturesData = null;
            
            // Clear any pending timeouts
            if (window.expressionUpdateTimeout) {
                clearTimeout(window.expressionUpdateTimeout);
                window.expressionUpdateTimeout = null;
            }
            
            // CRITICAL: Force clear all input values to prevent browser autocomplete from restoring them
            setTimeout(() => {
                // Clear type select
                const typeSelect = document.getElementById('singleTradeType');
                if (typeSelect) typeSelect.value = '';
                
                // Clear primary instrument
                const primaryInstrument = document.getElementById('singleInstrument');
                if (primaryInstrument) primaryInstrument.value = '';
                
                // Clear secondary instrument
                const secondaryInstrument = document.getElementById('secondaryInstrument');
                if (secondaryInstrument) secondaryInstrument.value = '';
                
                // Clear modal title again
                const modalTitle = document.getElementById('modalTitle');
                if (modalTitle) modalTitle.value = '';
                
                console.log('‚úÖ Explicitly cleared all input values to prevent autocomplete');
            }, 10);
            
            console.log('‚úÖ Fresh modal structure built');
        }
        
        function addInstrumentLine() {
            const tbody = document.getElementById('basicInfoTableBody');
            const newRow = document.createElement('tr');
            
            newRow.innerHTML = `
                <td>
                    <select class="modal-trade-type" onchange="updateLiveRate(this)" oninput="updateLiveRate(this)">
                        <option value="">Select Type</option>
                        <option value="swap">Swap</option>
                        <option value="future">Future/FX</option>
                        <option value="efp">EFP</option>
                    </select>
                </td>
                <td>
                    <input type="text" class="modal-instrument" placeholder="e.g., aud.5y5y" onchange="updateLiveRate(this)" oninput="updateLiveRate(this)" onblur="updateLiveRate(this)">
                </td>
                <td style="position: relative;">
                    <span class="live-rate-display" style="color: #cccccc; padding: 4px 8px; display: inline-block; min-width: 75px; text-align: center;">--</span>
                    <button class="btn-remove" onclick="removeInstrumentLine(this)" style="position: absolute; right: -60px; top: 50%; transform: translateY(-50%);">remove</button>
                </td>
                <td>
                    <span class="total-pnl-display" style="color: #cccccc; padding: 4px 8px; display: inline-block; min-width: 70px; text-align: center;">--</span>
                </td>
            `;
            
            tbody.appendChild(newRow);
        }
        
        function removeInstrumentLine(button) {
            // Find the associated row by looking for the row that has this button as its removeButton
            const tbody = document.getElementById('basicInfoTableBody');
            const rows = tbody.querySelectorAll('tr');
            
            rows.forEach(row => {
                if (row.removeButton === button) {
                    row.remove();
                    button.remove(); // Also remove the button itself
                }
            });
        }
        
        function addPosition(tableType = 'primary') {
            console.log(`‚ûï ADD POSITION CLICKED (${tableType.toUpperCase()})`);
            
            // Step 1: Determine trade type and instrument
            let tradeType, instrument;
            
            if (tableType === 'secondary') {
                // Secondary = futures leg of EFP
                const secondaryRow = document.getElementById('secondaryInstrumentRow');
                const instrumentInput = secondaryRow?.querySelector('.modal-instrument-secondary');
                tradeType = 'future';
                instrument = instrumentInput?.value.trim() || '';
            } else {
                // Primary = main trade or swap leg of EFP
                const basicInfoRow = document.querySelector('#basicInfoTableBody tr:first-child');
                const tradeTypeSelect = basicInfoRow?.querySelector('.modal-trade-type');
                const instrumentInput = basicInfoRow?.querySelector('.modal-instrument');
                const rawType = tradeTypeSelect?.value.trim() || '';
                tradeType = rawType === 'efp' ? 'swap' : rawType;
                instrument = instrumentInput?.value.trim() || '';
            }
            
            console.log(`üìä Type: ${tradeType}, Instrument: ${instrument}`);
            
            // Step 2: Add UI row directly (without backend call)
            // The position will only be saved to JSON when user clicks "Save Trade"
            console.log('üé® Adding UI row without modifying JSON...');
            addPositionUIRow(tableType, tradeType, instrument);
        }
        
        function addPositionUIRow(tableType, tradeType, instrument) {
            console.log(`üé® Adding UI row for ${tableType} position`);
            
            // Determine which table to add to
            const tbody = tableType === 'secondary' 
                ? document.getElementById('secondaryPositionsTableBody')
                : document.getElementById('positionsTableBody');
            
            const row = document.createElement('tr');
            const positionId = `position_${positionCounter++}`;
            
            console.log(`üîß Adding ${tableType} position for type:`, tradeType, 'instrument:', instrument);
            
            let sizeCell = '';
            
            if (tradeType === 'future' && instrument) {
                // Parse the futures expression to check for multiple components
                const components = parseFuturesExpressionComponents(instrument);
                
                if (components.length > 1) {
                    // Multiple components - show individual size inputs
                    sizeCell = '<td><div style="display: flex; flex-direction: column; gap: 4px;">';
                    components.forEach((comp, idx) => {
                        sizeCell += `
                            <div style="display: flex; align-items: center; gap: 4px;">
                                <span style="font-size: 10px; color: #888; min-width: 80px;">${comp.instrument}:</span>
                                <input type="number" data-position-size="${positionId}" data-component-index="${idx}" 
                                       placeholder="25" onchange="handlePositionChange(this)" step="1" 
                                       style="width: 60px; font-size: 11px;">
                            </div>
                        `;
                    });
                    sizeCell += '</div></td>';
                } else {
                    // Single component or simple expression
                    sizeCell = `
                        <td>
                            <input type="number" data-position-size="${positionId}" placeholder="25" 
                                   onchange="handlePositionChange(this)" step="1">
                        </td>
                    `;
                }
            } else {
                // Non-futures or no instrument yet
                sizeCell = `
                    <td>
                        <input type="number" data-position-size="${positionId}" placeholder="25" 
                               onchange="handlePositionChange(this)" step="1">
                    </td>
                `;
            }
            
            row.innerHTML = `
                <td>
                    <input type="number" data-position-price="${positionId}" placeholder="3.14" 
                           onchange="handlePositionChange(this)" step="0.01">
                </td>
                ${sizeCell}
                <td>
                    <input type="date" data-position-insertion-date="${positionId}" value="${new Date().toISOString().split('T')[0]}"
                           onchange="handlePositionChange(this)" style="width: 100px; font-size: 11px;">
                </td>
                <td style="position: relative;">
                    <span class="pnl-display" style="color: #cccccc; padding: 4px 8px; display: inline-block; min-width: 60px; text-align: center;">--</span>
                    <button class="btn-remove" onclick="removePosition(this)" style="position: absolute; right: -60px; top: 50%; transform: translateY(-50%);">remove</button>
                </td>
            `;
            
            tbody.appendChild(row);
            console.log(`‚úÖ Added ${tableType} position to table`);
        }
        
        function parseFuturesExpressionComponents(expression) {
            // Simple parser for futures expressions like "ymz5 comdty - xmz5 comdty"
            const expr = expression.toLowerCase().trim();
            
            // Pattern to match futures instruments
            const instrumentPattern = /[a-z0-9]+\s+(?:comdty|curncy|index)/g;
            const instruments = expr.match(instrumentPattern) || [];
            
            if (instruments.length === 0) {
                // Treat as single instrument
                return [{ instrument: expression.trim(), coefficient: 1.0 }];
            }
            
            // Parse coefficients
            const components = [];
            let temp_expr = expr;
            const positions = {};
            
            instruments.forEach((inst, i) => {
                const placeholder = `__fut_${i}__`;
                positions[placeholder] = inst.trim();
                temp_expr = temp_expr.replace(inst, placeholder);
            });
            
            // Split by operators
            const parts = temp_expr.split(/(\+|\-)/);
            let current_sign = 1;
            
            for (const part of parts) {
                const trimmed = part.trim();
                if (trimmed === '+') {
                    current_sign = 1;
                } else if (trimmed === '-') {
                    current_sign = -1;
                } else if (trimmed) {
                    let coefficient = current_sign;
                    let placeholder = trimmed;
                    
                    if (trimmed.includes('*')) {
                        const [coeff, inst] = trimmed.split('*');
                        coefficient = parseFloat(coeff.trim()) * current_sign;
                        placeholder = inst.trim();
                    }
                    
                    if (positions[placeholder]) {
                        components.push({
                            instrument: positions[placeholder],
                            coefficient: coefficient
                        });
                    }
                }
            }
            
            return components.length > 0 ? components : [{ instrument: expression.trim(), coefficient: 1.0 }];
        }
        
        function refreshFuturesDataIfNeeded() {
            // Check if this is a futures trade
            const basicInfoRow = document.querySelector('#basicInfoTableBody tr');
            if (!basicInfoRow) return;
            
            const tradeTypeSelect = basicInfoRow.querySelector('.modal-trade-type');
            const instrumentInput = basicInfoRow.querySelector('.modal-instrument');
            
            if (!tradeTypeSelect || !instrumentInput) return;
            
            const tradeType = tradeTypeSelect.value.trim();
            const instrument = instrumentInput.value.trim();
            
            if (tradeType === 'future' && instrument) {
                console.log('üîÑ Fetching fresh futures data for new position:', instrument);
                
                // Call backend to get futures details
                fetch('/get_realtime_rates', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        expressions: [{
                            label: 'cache',
                            expression: instrument,
                            type: 'future'
                        }]
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Store this as our cached data for subsequent P&L calculations
                        cachedFuturesData = {
                            instrument: instrument,
                            timestamp: new Date().toISOString(),
                            data: data
                        };
                        console.log('‚úÖ Futures data cached:', cachedFuturesData);
                    }
                })
                .catch(error => {
                    console.error('‚ùå Error fetching futures data:', error);
                });
            }
        }
        
        function getAvailableInstruments() {
            const basicInfoRows = document.getElementById('basicInfoTableBody').querySelectorAll('tr');
            let options = '';
            
            basicInfoRows.forEach((row, index) => {
                const instrumentInput = row.querySelector('input.modal-instrument');
                if (instrumentInput && instrumentInput.value.trim()) {
                    const instrument = instrumentInput.value.trim();
                    options += `<option value="${instrument}">${instrument}</option>`;
                }
            });
            
            return options;
        }
        
        // Function to update positions header based on trade type and instrument
        function updatePositionsHeader() {
            const primarySizeHeader = document.getElementById('primarySizeHeader');
            if (!primarySizeHeader) {
                console.log('‚ùå Primary size header element not found');
                return;
            }
            
            // Get trade type and instrument from primary row
            const basicInfoRow = document.querySelector('#basicInfoTableBody tr:first-child');
            if (!basicInfoRow) {
                console.log('‚ùå Basic info row not found');
                return;
            }
            
            const tradeTypeSelect = basicInfoRow.querySelector('.modal-trade-type');
            const instrumentInput = basicInfoRow.querySelector('.modal-instrument');
            
            const tradeType = tradeTypeSelect ? tradeTypeSelect.value.trim() : '';
            const instrument = instrumentInput ? instrumentInput.value.trim().toLowerCase() : '';
            
            console.log('üìä Updating header - Type:', tradeType, 'Instrument:', instrument);
            console.log('üîç Header update details:', {
                tradeTypeElement: !!tradeTypeSelect,
                instrumentElement: !!instrumentInput, 
                tradeTypeValue: tradeType,
                instrumentValue: instrument,
                containsCurncy: instrument.includes('curncy'),
                isFutureType: tradeType === 'future'
            });
            
            if (tradeType === 'future') {
                if (instrument.includes('curncy')) {
                    primarySizeHeader.textContent = 'Million';
                    console.log('üí∞ Set header to "Million" (future + curncy detected)');
                } else {
                    primarySizeHeader.textContent = 'Lots';
                    console.log('üì¶ Set header to "Lots" (future, no curncy)');
                }
            } else {
                primarySizeHeader.textContent = '01';
                console.log('üìä Set header to "01" (non-future type)');
            }
        }
        
        // Function to handle type change and show/hide secondary instrument row for EFP
        function handleTypeChange(selectElement) {
            console.log('üîÑ Type changed:', selectElement.value);
            
            const secondaryRow = document.getElementById('secondaryInstrumentRow');
            const secondaryPositionsSection = document.getElementById('secondaryPositionsSection');
            const primaryPositionsTitle = document.getElementById('primaryPositionsTitle');
            const secondaryPositionsTableBody = document.getElementById('secondaryPositionsTableBody');
            
            console.log('üîç Elements found:', {
                secondaryRow: !!secondaryRow,
                secondaryPositionsSection: !!secondaryPositionsSection,
                primaryPositionsTitle: !!primaryPositionsTitle,
                secondaryPositionsTableBody: !!secondaryPositionsTableBody
            });
            
            const efpTotalRow = document.getElementById('efpTotalRow');
            
            // Update primary positions header based on trade type and instrument
            updatePositionsHeader();
            
            if (selectElement.value === 'efp') {
                console.log('‚úÖ EFP selected - showing secondary sections');
                
                // FORCE show secondary instrument row and positions section for EFP
                if (secondaryRow) {
                    secondaryRow.style.display = 'table-row';
                    secondaryRow.style.visibility = 'visible';
                    secondaryRow.style.opacity = '1';
                    console.log('‚úÖ Secondary row display set to:', secondaryRow.style.display);
                } else {
                    console.error('‚ùå Secondary row not found!');
                }
                
                // Show EFP total row
                if (efpTotalRow) {
                    efpTotalRow.style.display = 'table-row';
                    efpTotalRow.style.visibility = 'visible';
                    efpTotalRow.style.opacity = '1';
                    console.log('‚úÖ EFP total row shown');
                } else {
                    console.error('‚ùå EFP total row not found!');
                }
                
                if (secondaryPositionsSection) {
                    secondaryPositionsSection.style.display = 'block';
                    secondaryPositionsSection.style.visibility = 'visible';
                    secondaryPositionsSection.style.opacity = '1';
                    console.log('‚úÖ Secondary positions section shown');
                } else {
                    console.error('‚ùå Secondary positions section not found!');
                }
                
                if (primaryPositionsTitle) {
                    primaryPositionsTitle.textContent = 'Swap Positions';
                    console.log('‚úÖ Primary positions title updated');
                }
                
                // Clear any existing secondary positions first
                if (secondaryPositionsTableBody) {
                    secondaryPositionsTableBody.innerHTML = '';
                    console.log('üßπ Cleared existing secondary positions before adding new one');
                }
                
                // Only auto-add a secondary position if this is a NEW trade (not editing)
                // When editing, positions will be loaded from backend data
                if (!currentTradeId) {
                    setTimeout(() => {
                        const tbody = document.getElementById('secondaryPositionsTableBody');
                        if (tbody && tbody.children.length === 0) {
                            console.log('‚ûï Auto-adding first secondary position for NEW EFP trade');
                            addPosition('secondary');
                        } else {
                            console.log(`üìä Secondary table already has ${tbody?.children.length || 0} positions`);
                        }
                    }, 100);
                } else {
                    console.log('üìù Editing existing EFP trade - positions will be loaded from backend, not auto-adding empty position');
                }
                
            } else {
                console.log('üìä Non-EFP selected - hiding secondary sections');
                
                // Hide secondary instrument row and positions section for non-EFP trades
                if (secondaryRow) {
                    secondaryRow.style.display = 'none';
                }
                if (efpTotalRow) {
                    efpTotalRow.style.display = 'none';
                }
                if (secondaryPositionsSection) {
                    secondaryPositionsSection.style.display = 'none';
                }
                if (primaryPositionsTitle) {
                    primaryPositionsTitle.textContent = 'Positions';
                }
                
                // Clear secondary positions when switching away from EFP
                if (secondaryPositionsTableBody) {
                    secondaryPositionsTableBody.innerHTML = '';
                    console.log('üóëÔ∏è Cleared secondary positions');
                }
            }
            
            // Also trigger live rate update
            updateLiveRate(selectElement);
        }
        
        // Function to handle instrument change and update header accordingly
        function handleInstrumentChange(inputElement) {
            console.log('üîÑ Instrument changed:', inputElement.value);
            
            // Add a small delay to ensure the input value is fully updated
            setTimeout(() => {
                // Update positions header based on new instrument
                updatePositionsHeader();
            }, 10);
            
            // Also update live rate
            updateLiveRate(inputElement);
        }
        
        function updateLiveRate(element) {
            console.log('üîç updateLiveRate called with element:', element);
            
            const row = element.closest('tr');
            console.log('üîç Found row:', row);
            
            const typeSelect = row.querySelector('.modal-trade-type');
            // Support both primary and secondary instrument inputs
            const instrumentInput = row.querySelector('.modal-instrument, .modal-instrument-secondary');
            const liveRateDisplay = row.querySelector('.live-rate-display');
            
            console.log('üîç Elements found:', { typeSelect, instrumentInput, liveRateDisplay });
            
            if (!instrumentInput || !liveRateDisplay) {
                console.log('‚ùå Missing required elements');
                return;
            }
            
            // For secondary row (EFP futures), type is always 'future'
            // For primary row, get from the type select (but convert 'efp' to 'swap')
            let type;
            if (row.id === 'secondaryInstrumentRow') {
                type = 'future';
            } else if (typeSelect) {
                type = typeSelect.value.trim();
                // EFP primary leg is always a swap
                if (type === 'efp') {
                    type = 'swap';
                }
            } else {
                console.log('‚ùå No type select found and not secondary row');
                return;
            }
            
            const instrument = instrumentInput.value.trim();
            
            console.log('üîç Values:', { type, instrument });
            
            // Fetch live rates for swaps and futures with valid instrument syntax
            if ((type === 'swap' || type === 'future') && instrument) {
                console.log(`üîÑ Fetching ${type} live rate for:`, instrument);
                liveRateDisplay.textContent = 'Loading...';
                liveRateDisplay.style.color = '#cccccc';
                
                if (type === 'swap') {
                    // For swaps: First check if curves are loaded
                    fetch('/curves_status')
                    .then(response => response.json())
                    .then(statusData => {
                        console.log('üìä Curves status:', statusData);
                        
                        if (!statusData.loaded) {
                            console.log('‚ö†Ô∏è Curves not loaded, cannot fetch swap live rates');
                            liveRateDisplay.textContent = 'No curves';
                            liveRateDisplay.style.color = '#ff9f43';
                            return;
                        }
                        
                        // Curves are loaded, proceed with swap rate fetch
                        console.log('‚úÖ Curves loaded, fetching swap rate for:', instrument);
                        
                        return fetch('/get_realtime_rates', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                expressions: [{
                                    label: 'temp',
                                    expression: instrument,
                                    type: type  // Pass the trade type to backend
                                }]
                            })
                        });
                    })
                    .then(response => {
                        if (!response) return; // Curves not loaded case
                        
                        console.log('üì° Swap rate fetch response status:', response.status);
                        return response.json();
                    })
                    .then(data => {
                        if (!data) return; // Curves not loaded case
                        
                        console.log('üìä Swap rate response data:', data);
                        
                        if (data.success && data.rates) {
                            const rate = data.rates.temp;
                            console.log('üìà Swap rate received:', rate);
                            
                            if (rate && rate !== '--') {
                                liveRateDisplay.textContent = parseFloat(rate).toFixed(4);
                                liveRateDisplay.style.color = '#00d4ff'; // Blue color for valid rates
                                console.log('‚úÖ Swap live rate updated:', rate);
                                
                                // Update EFP spread if this is part of an EFP trade
                                updateEFPSpread();
                            } else {
                                liveRateDisplay.textContent = '--';
                                liveRateDisplay.style.color = '#cccccc';
                                console.log('‚ùå No swap live rate available for:', instrument);
                            }
                        } else {
                            liveRateDisplay.textContent = '--';
                            liveRateDisplay.style.color = '#cccccc';
                            console.error('‚ùå Error in swap response:', data.error || 'No success flag');
                        }
                    })
                    .catch(error => {
                        console.error('‚ùå Network error fetching swap live rate:', error);
                        liveRateDisplay.textContent = 'Error';
                        liveRateDisplay.style.color = '#ff6b6b'; // Red color for errors
                    });
                    
                } else if (type === 'future') {
                    // For futures: Fetch rate directly (no curves dependency)
                    console.log('üîÑ Fetching futures rate for:', instrument);
                    
                    fetch('/get_realtime_rates', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            expressions: [{
                                label: 'temp',
                                expression: instrument,
                                type: type  // Pass the trade type to backend
                            }]
                        })
                    })
                    .then(response => {
                        console.log('üì° Futures rate fetch response status:', response.status);
                        return response.json();
                    })
                    .then(data => {
                        console.log('üìä Futures rate response data:', data);
                        
                        if (data.success && data.rates) {
                            const rate = data.rates.temp;
                            console.log('üìà Futures rate received:', rate);
                            
                            if (rate && rate !== '--') {
                                liveRateDisplay.textContent = parseFloat(rate).toFixed(4);
                                liveRateDisplay.style.color = '#00d4ff'; // Blue color for valid rates
                                console.log('‚úÖ Futures live rate updated:', rate);
                                
                                // Update EFP spread if this is part of an EFP trade
                                updateEFPSpread();
                            } else {
                                liveRateDisplay.textContent = '--';
                                liveRateDisplay.style.color = '#cccccc';
                                console.log('‚ùå No futures live rate available for:', instrument);
                            }
                        } else {
                            liveRateDisplay.textContent = '--';
                            liveRateDisplay.style.color = '#cccccc';
                            console.error('‚ùå Error in futures response:', data.error || 'No success flag');
                        }
                    })
                    .catch(error => {
                        console.error('‚ùå Network error fetching futures live rate:', error);
                        liveRateDisplay.textContent = 'Error';
                        liveRateDisplay.style.color = '#ff6b6b'; // Red color for errors
                    });
                }
                
            } else {
                console.log('üîç Not fetching rate - type:', type, 'instrument:', instrument);
                liveRateDisplay.textContent = '--';
                liveRateDisplay.style.color = '#cccccc';
            }
        }
        
        function removePosition(button) {
            button.closest('tr').remove();
        }
        
        function saveTrade() {
            // Validate form first
            if (!validateTradeForm()) {
                return; // Validation failed, errors are already displayed
            }
            
            // Collect basic trade info from the table
            const tradeIdentifier = document.getElementById('modalTitle').value.trim();
            
            // Collect primary row (first row)
            const primaryRow = document.querySelector('#basicInfoTableBody tr:first-child');
            const primaryTypeSelect = primaryRow.querySelector('select.modal-trade-type');
            const primaryInstrumentInput = primaryRow.querySelector('input.modal-instrument');
            
            // Group ID is now in the top section, not in the table
            const groupIdInput = document.getElementById('singleGroupId');
            
            const primaryType = primaryTypeSelect ? primaryTypeSelect.value.trim() : '';
            const primaryInstrument = primaryInstrumentInput ? primaryInstrumentInput.value.trim() : '';
            const groupId = groupIdInput ? groupIdInput.value.trim() : '';
            
            console.log('üìä Primary:', { type: primaryType, instrument: primaryInstrument, groupId: groupId });
            
            // Check if it's an EFP trade - collect secondary row if present
            let secondaryType = null;
            let secondaryInstrument = null;
            
            if (primaryType === 'efp') {
                const secondaryRow = document.getElementById('secondaryInstrumentRow');
                if (secondaryRow && secondaryRow.style.display !== 'none') {
                    const secondaryInstrumentInput = secondaryRow.querySelector('input.modal-instrument-secondary');
                    secondaryInstrument = secondaryInstrumentInput ? secondaryInstrumentInput.value.trim() : '';
                    secondaryType = 'future'; // EFP secondary is always futures
                    
                    console.log('üìä Secondary (EFP):', { type: secondaryType, instrument: secondaryInstrument });
                }
            }
            
            // Build typologies and instruments arrays
            const typologies = [];
            const instruments = [];
            
            if (primaryType && primaryInstrument) {
                typologies.push(primaryType);
                instruments.push(primaryInstrument);
            }
            
            if (secondaryType && secondaryInstrument) {
                typologies.push(secondaryType);
                instruments.push(secondaryInstrument);
            }
            
            console.log('üìä Final arrays:', { typologies, instruments });
            
            // Collect PRIMARY positions (swap leg for EFP, or main positions for other types)
            const primaryPositions = [];
            const primaryInsertionDates = [];
            const primaryRows = document.getElementById('positionsTableBody').querySelectorAll('tr');
            
            console.log('üîç Found', primaryRows.length, 'PRIMARY position rows to process');
            
            primaryRows.forEach((row, rowIndex) => {
                console.log(`üîç Processing PRIMARY position row ${rowIndex + 1}`);
                
                const priceInput = row.querySelector('[data-position-price]');
                const price = priceInput ? priceInput.value.trim() : '';
                
                // CRITICAL FIX: Collect insertion date from each position row
                const insertionDateInput = row.querySelector('[data-position-insertion-date]');
                const insertionDate = insertionDateInput ? insertionDateInput.value.trim() : '';
                
                console.log(`  üìÖ Insertion date for PRIMARY position ${rowIndex + 1}:`, insertionDate || 'not set');
                
                if (price) {
                    const sizeInputs = row.querySelectorAll('[data-position-size]');
                    
                    if (sizeInputs.length > 1) {
                        // Multiple component sizes
                        const componentSizes = [];
                        let allSizesValid = true;
                        
                        sizeInputs.forEach((sizeInput, sizeIndex) => {
                            const size = sizeInput.value.trim();
                            if (size) {
                                componentSizes.push(parseFloat(size));
                            } else {
                                allSizesValid = false;
                            }
                        });
                        
                        if (allSizesValid && componentSizes.length > 0) {
                            primaryPositions.push({
                                price: parseFloat(price),
                                size: componentSizes
                            });
                            primaryInsertionDates.push(insertionDate || null);
                            console.log(`  ‚úÖ Added PRIMARY position with multiple sizes:`, { price: parseFloat(price), size: componentSizes, insertionDate: insertionDate });
                        }
                    } else {
                        // Single size input
                        const sizeInput = row.querySelector('[data-position-size]');
                        const size = sizeInput ? sizeInput.value.trim() : '';
                        
                        if (size) {
                            primaryPositions.push({
                                price: parseFloat(price),
                                size: parseFloat(size)
                            });
                            primaryInsertionDates.push(insertionDate || null);
                            console.log(`  ‚úÖ Added PRIMARY position with single size:`, { price: parseFloat(price), size: parseFloat(size), insertionDate: insertionDate });
                        }
                    }
                }
            });
            
            console.log('üìã Total PRIMARY positions collected:', primaryPositions);
            console.log('üìÖ Total PRIMARY insertion dates collected:', primaryInsertionDates);
            
            // Collect SECONDARY positions (futures leg for EFP only)
            const secondaryPositions = [];
            const secondaryInsertionDates = [];
            if (primaryType === 'efp') {
                const secondaryRows = document.getElementById('secondaryPositionsTableBody').querySelectorAll('tr');
                console.log('üîç Found', secondaryRows.length, 'SECONDARY position rows to process');
                
                secondaryRows.forEach((row, rowIndex) => {
                    console.log(`üîç Processing SECONDARY position row ${rowIndex + 1}`);
                    
                    const priceInput = row.querySelector('[data-position-price]');
                    const price = priceInput ? priceInput.value.trim() : '';
                    
                    // CRITICAL FIX: Collect insertion date from each secondary position row
                    const insertionDateInput = row.querySelector('[data-position-insertion-date]');
                    const insertionDate = insertionDateInput ? insertionDateInput.value.trim() : '';
                    
                    console.log(`  üìÖ Insertion date for SECONDARY position ${rowIndex + 1}:`, insertionDate || 'not set');
                    
                    if (price) {
                        const sizeInputs = row.querySelectorAll('[data-position-size]');
                        
                        if (sizeInputs.length > 1) {
                            // Multiple component sizes
                            const componentSizes = [];
                            let allSizesValid = true;
                            
                            sizeInputs.forEach((sizeInput, sizeIndex) => {
                                const size = sizeInput.value.trim();
                                if (size) {
                                    componentSizes.push(parseFloat(size));
                                } else {
                                    allSizesValid = false;
                                }
                            });
                            
                            if (allSizesValid && componentSizes.length > 0) {
                                secondaryPositions.push({
                                    price: parseFloat(price),
                                    size: componentSizes
                                });
                                secondaryInsertionDates.push(insertionDate || null);
                                console.log(`  ‚úÖ Added SECONDARY position with multiple sizes:`, { price: parseFloat(price), size: componentSizes, insertionDate: insertionDate });
                            }
                        } else {
                            // Single size input
                            const sizeInput = row.querySelector('[data-position-size]');
                            const size = sizeInput ? sizeInput.value.trim() : '';
                            
                            if (size) {
                                secondaryPositions.push({
                                    price: parseFloat(price),
                                    size: parseFloat(size)
                                });
                                secondaryInsertionDates.push(insertionDate || null);
                                console.log(`  ‚úÖ Added SECONDARY position with single size:`, { price: parseFloat(price), size: parseFloat(size), insertionDate: insertionDate });
                            }
                        }
                    }
                });
                
                console.log('üìã Total SECONDARY positions collected:', secondaryPositions);
                console.log('üìÖ Total SECONDARY insertion dates collected:', secondaryInsertionDates);
            }
            
            // For non-EFP trades, use primary positions as entry positions
            // For EFP trades, send separate arrays for primary and secondary positions
            let entryPositions, exitPositions, entryPositionsSecondary;
            
            if (primaryType === 'efp' && secondaryPositions.length > 0) {
                // EFP: Send separate arrays for primary (swap) and secondary (futures) positions
                entryPositions = primaryPositions;
                entryPositionsSecondary = secondaryPositions;
                exitPositions = [];
                console.log('üìä EFP trade: Primary positions:', entryPositions);
                console.log('üìä EFP trade: Secondary positions:', entryPositionsSecondary);
            } else {
                // Non-EFP: Use primary positions only
                entryPositions = primaryPositions;
                entryPositionsSecondary = null;
                exitPositions = [];
                console.log('üìä Non-EFP trade: Using primary positions only:', entryPositions);
            }
            
            // Check if we're editing an existing trade or creating a new one
            // If currentTradeId is a datetime-based ID (contains underscore like 20251111_154430)
            // and user entered a different identifier, treat as new trade creation
            const isTemporaryId = currentTradeId && currentTradeId.match(/^\d{8}_\d{6}$/);
            const needsRename = isTemporaryId && tradeIdentifier !== currentTradeId;
            
            if (currentTradeId && !needsRename) {
                // Updating existing trade (and not renaming)
                console.log('üíæ Updating existing trade:', currentTradeId);
                
                const updateData = {
                    trade_id: currentTradeId,
                    typologies: typologies,
                    instruments: instruments,
                    entry_prices: entryPositions.map(p => p.price),
                    entry_sizes: entryPositions.map(p => p.size),
                    exit_prices: exitPositions.map(p => p.price),
                    exit_sizes: exitPositions.map(p => p.size),
                    group_id: groupId,
                    entry_insertion_dates: primaryInsertionDates
                };
                
                console.log('üìÖ Including primary insertion dates:', primaryInsertionDates);
                
                // Add secondary positions for EFP trades
                if (entryPositionsSecondary && entryPositionsSecondary.length > 0) {
                    updateData.entry_prices_secondary = entryPositionsSecondary.map(p => p.price);
                    updateData.entry_sizes_secondary = entryPositionsSecondary.map(p => p.size);
                    updateData.entry_insertion_dates_secondary = secondaryInsertionDates;
                    console.log('üìä Including secondary positions:', updateData.entry_prices_secondary, updateData.entry_sizes_secondary);
                    console.log('üìÖ Including secondary insertion dates:', secondaryInsertionDates);
                }
                
                fetch('/update_trade', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(updateData)
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        console.log('‚úÖ Trade updated successfully');
                        
                        // CLEAR BACKUP: Changes were saved successfully
                        portfolioBackup = null;
                        console.log('‚úÖ Portfolio backup cleared after successful save');
                        
                        // Check if curves exist and auto-update P&L for the updated trade
                        fetch('/curves_status')
                        .then(response => response.json())
                        .then(curveData => {
                            if (curveData.loaded) {
                                console.log('‚úÖ Curves exist, auto-updating P&L for updated trade...');
                                
                                // Auto-update P&L since curves exist
                                fetch('/update_realtime_pnl', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' }
                                })
                                .then(response => response.json())
                                .then(pnlData => {
                                    if (pnlData.success) {
                                        console.log('‚úÖ Auto P&L update successful for updated trade');
                                    }
                                    closeTradeModal();
                                    loadTradesFromBackend();
                                    updateCharts();
                                })
                                .catch(error => {
                                    console.error('‚ùå Auto P&L update error:', error);
                                    closeTradeModal();
                                    loadTradesFromBackend();
                                    updateCharts();
                                });
                            } else {
                                console.log('üìä No curves, just saving updated trade without P&L update');
                                closeTradeModal();
                                loadTradesFromBackend();
                                updateCharts();
                            }
                        })
                        .catch(error => {
                            console.error('‚ùå Error checking curves:', error);
                            closeTradeModal();
                            loadTradesFromBackend();
                            updateCharts();
                        });
                        
                    } else {
                        alert('Error updating trade: ' + (data.error || 'Unknown error'));
                    }
                })
                .catch(error => {
                    console.error('‚ùå Error updating trade:', error);
                    alert('Error updating trade: ' + error.message);
                });
                
            } else {
                // Creating new trade
                console.log('üíæ Creating new trade with ID:', tradeIdentifier);
                
                const submitData = {
                    name: tradeIdentifier || `Trade ${Date.now()}`,
                    typologies: typologies,
                    instruments: instruments,
                    entry_prices: entryPositions.map(p => p.price),
                    entry_sizes: entryPositions.map(p => p.size),
                    exit_prices: exitPositions.map(p => p.price),
                    exit_sizes: exitPositions.map(p => p.size),
                    group_id: groupId,
                    entry_insertion_dates: primaryInsertionDates
                };
                
                console.log('üìÖ Including primary insertion dates:', primaryInsertionDates);
                
                // Add secondary positions for EFP trades
                if (entryPositionsSecondary && entryPositionsSecondary.length > 0) {
                    submitData.entry_prices_secondary = entryPositionsSecondary.map(p => p.price);
                    submitData.entry_sizes_secondary = entryPositionsSecondary.map(p => p.size);
                    submitData.entry_insertion_dates_secondary = secondaryInsertionDates;
                    console.log('üìä Including secondary positions:', submitData.entry_prices_secondary, submitData.entry_sizes_secondary);
                    console.log('üìÖ Including secondary insertion dates:', secondaryInsertionDates);
                }
                
                fetch('/add_trade', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(submitData)
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        console.log('‚úÖ Trade created successfully');
                        
                        // CLEAR BACKUP: Changes were saved successfully
                        portfolioBackup = null;
                        console.log('‚úÖ Portfolio backup cleared after successful save');
                        
                        // Check if curves exist and auto-update P&L for the new trade
                        fetch('/curves_status')
                        .then(response => response.json())
                        .then(curveData => {
                            if (curveData.loaded) {
                                console.log('‚úÖ Curves exist, auto-updating P&L for new trade...');
                                
                                // Auto-update P&L since curves exist
                                fetch('/update_realtime_pnl', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' }
                                })
                                .then(response => response.json())
                                .then(pnlData => {
                                    if (pnlData.success) {
                                        console.log('‚úÖ Auto P&L update successful for new trade');
                                    }
                                    closeTradeModal();
                                    loadTradesFromBackend();
                                    updateCharts();
                                })
                                .catch(error => {
                                    console.error('‚ùå Auto P&L update error:', error);
                                    closeTradeModal();
                                    loadTradesFromBackend();
                                    updateCharts();
                                });
                            } else {
                                console.log('üìä No curves, just saving trade without P&L update');
                                closeTradeModal();
                                loadTradesFromBackend();
                                updateCharts();
                            }
                        })
                        .catch(error => {
                            console.error('‚ùå Error checking curves:', error);
                            closeTradeModal();
                            loadTradesFromBackend();
                            updateCharts();
                        });
                        
                    } else {
                        alert('Error adding trade: ' + (data.error || 'Unknown error'));
                    }
                })
                .catch(error => {
                    console.error('‚ùå Error adding trade:', error);
                    alert('Error adding trade: ' + error.message);
                });
            }
        }
        
        function displayTradesInGrid() {
            const tbody = document.getElementById('tradesGridBody');
            tbody.innerHTML = '';
            
            // Group trades by group_id
            const groupedTrades = {};
            const ungroupedTrades = [];
            
            storedTrades.forEach(trade => {
                if (trade.groupId && trade.groupId.trim()) {
                    const groupId = trade.groupId.trim();
                    if (!groupedTrades[groupId]) {
                        groupedTrades[groupId] = [];
                    }
                    groupedTrades[groupId].push(trade);
                } else {
                    ungroupedTrades.push(trade);
                }
            });
            
            // Display grouped trades first
            Object.keys(groupedTrades).forEach(groupId => {
                const trades = groupedTrades[groupId];
                displayTradeGroup(tbody, groupId, trades);
            });
            
            // Display ungrouped trades
            ungroupedTrades.forEach(trade => {
                displaySingleTrade(tbody, trade, false);
            });
        }
        
        function displayTradeGroup(tbody, groupId, trades) {
            // Calculate group totals
            let groupTotalPnL = 0;
            let groupTotalSize = 0;
            let groupPnLColor = '#00d4ff';
            
            trades.forEach(trade => {
                // Calculate P&L for each trade in group
                let tradePnL = 0;
                if (trade.type === 'efp' && (trade.storedPnLPrimary !== undefined || trade.storedPnLSecondary !== undefined)) {
                    const primaryPnL = trade.storedPnLPrimary !== undefined ? trade.storedPnLPrimary : 0;
                    const secondaryPnL = trade.storedPnLSecondary !== undefined ? trade.storedPnLSecondary : 0;
                    tradePnL = primaryPnL + secondaryPnL;
                } else if (trade.storedPnL && trade.storedPnL !== '--' && trade.storedPnL !== 'No curves') {
                    tradePnL = parseFloat(trade.storedPnL.replace(/[$,]/g, '')) || 0;
                }
                
                groupTotalPnL += tradePnL;
                groupTotalSize += trade.totalSize || 0;
            });
            
            // Determine group P&L color
            if (groupTotalPnL > 0) {
                groupPnLColor = '#51cf66'; // Green for profit
            } else if (groupTotalPnL < 0) {
                groupPnLColor = '#ff6b6b'; // Red for loss
            }
            
            const groupPnLDisplay = `$${groupTotalPnL.toLocaleString('en-US', {
                minimumFractionDigits: 0,
                maximumFractionDigits: 0
            })}`;
            
            // Create group header row
            const groupHeaderRow = document.createElement('tr');
            groupHeaderRow.className = 'trade-group-header';
            groupHeaderRow.innerHTML = `
                <td onclick="toggleTradeGroup('${groupId}')" style="cursor: pointer;">
                    <span class="group-arrow" id="group-arrow-${groupId}">‚ñº</span>Group
                </td>
                <td onclick="toggleTradeGroup('${groupId}')" style="cursor: pointer;">${groupId}</td>
                <td onclick="toggleTradeGroup('${groupId}')" style="cursor: pointer;">
                    <span class="group-summary">${trades.length} trades</span>
                </td>
                <td onclick="toggleTradeGroup('${groupId}')" style="cursor: pointer;">--</td>
                <td onclick="toggleTradeGroup('${groupId}')" style="cursor: pointer;">${groupTotalSize.toFixed(0)}</td>
                <td onclick="toggleTradeGroup('${groupId}')" style="cursor: pointer; color: ${groupPnLColor}; font-size: 11px;">${groupPnLDisplay}</td>
                <td onclick="toggleTradeGroup('${groupId}')" style="cursor: pointer;">--</td>
                <td onclick="toggleTradeGroup('${groupId}')" style="cursor: pointer;">--</td>
                <td onclick="toggleTradeGroup('${groupId}')" style="cursor: pointer;">--</td>
                <td onclick="toggleTradeGroup('${groupId}')" style="cursor: pointer;">--</td>
                <td onclick="toggleTradeGroup('${groupId}')" style="cursor: pointer;">--</td>
                <td onclick="toggleTradeGroup('${groupId}')" style="cursor: pointer;">--</td>
                <td onclick="toggleTradeGroup('${groupId}')" style="cursor: pointer;">--</td>
                <td style="text-align: center; padding: 4px;">
                    <button class="btn-pnl" onclick="showGroupPnL('${groupId}'); event.stopPropagation();" style="position: static;">PnL</button>
                </td>
                <td style="text-align: center; padding: 4px;">
                    <span class="group-summary">${trades.length} trades</span>
                </td>
            `;
            
            tbody.appendChild(groupHeaderRow);
            
            // Add individual trades as group members
            trades.forEach(trade => {
                displaySingleTrade(tbody, trade, true, groupId);
            });
        }
        
        function displaySingleTrade(tbody, trade, isGroupMember = false, groupId = null) {
            const row = document.createElement('tr');
            
            // Add group member class if this trade is part of a group
            if (isGroupMember) {
                row.className = 'trade-group-member';
                row.setAttribute('data-group-id', groupId);
            }
            
            // Display single total P&L for all trade types
            let pnlDisplay, pnlColor;
            
            if (trade.type === 'efp' && (trade.storedPnLPrimary !== undefined || trade.storedPnLSecondary !== undefined)) {
                // EFP: Calculate total P&L from swap + futures
                const primaryPnL = trade.storedPnLPrimary !== undefined ? trade.storedPnLPrimary : 0;
                const secondaryPnL = trade.storedPnLSecondary !== undefined ? trade.storedPnLSecondary : 0;
                const totalPnL = primaryPnL + secondaryPnL;
                
                console.log(`üí∞ EFP Display - Primary: ${primaryPnL}, Secondary: ${secondaryPnL}, Total: ${totalPnL}`);
                
                // Format as currency
                pnlDisplay = `$${totalPnL.toLocaleString('en-US', {
                    minimumFractionDigits: 0,
                    maximumFractionDigits: 0
                })}`;
                
                // Determine color based on total P&L
                if (totalPnL > 0) {
                    pnlColor = '#51cf66'; // Green for profit
                } else if (totalPnL < 0) {
                    pnlColor = '#ff6b6b'; // Red for loss
                } else {
                    pnlColor = '#00d4ff'; // Aqua for zero
                }
            } else {
                // Non-EFP or single P&L
                pnlDisplay = trade.storedPnL || '--';
                pnlColor = '#00d4ff'; // Default aqua color
                
                if (pnlDisplay !== '--' && pnlDisplay !== 'No curves') {
                    // Extract numeric value from P&L display (e.g., "$1,234" -> 1234)
                    const pnlValue = parseFloat(pnlDisplay.replace(/[$,]/g, ''));
                    if (!isNaN(pnlValue)) {
                        if (pnlValue > 0) {
                            pnlColor = '#51cf66'; // Green for profit
                        } else if (pnlValue < 0) {
                            pnlColor = '#ff6b6b'; // Red for loss
                        }
                    }
                }
            }
            
            row.innerHTML = `
                <td onclick="openTradeModal('${trade.id}')" style="cursor: pointer;">${trade.type}</td>
                <td onclick="openTradeModal('${trade.id}')" style="cursor: pointer;">${trade.identifier}</td>
                <td onclick="openTradeModal('${trade.id}')" style="cursor: pointer;">${trade.instrument}</td>
                <td onclick="openTradeModal('${trade.id}')" style="cursor: pointer;">${trade.avgEntry.toFixed(2)}%</td>
                <td onclick="openTradeModal('${trade.id}')" style="cursor: pointer;">${trade.totalSize.toFixed(0)}</td>
                <td onclick="openTradeModal('${trade.id}')" style="cursor: pointer; color: ${pnlColor}; font-size: 11px;" class="pnl-cell">${pnlDisplay}</td>
                <td onclick="openTradeModal('${trade.id}')" style="cursor: pointer;">--</td>
                <td onclick="openTradeModal('${trade.id}')" style="cursor: pointer;">--</td>
                <td onclick="openTradeModal('${trade.id}')" style="cursor: pointer;">--</td>
                <td onclick="openTradeModal('${trade.id}')" style="cursor: pointer;">--</td>
                <td onclick="openTradeModal('${trade.id}')" style="cursor: pointer;">--</td>
                <td onclick="openTradeModal('${trade.id}')" style="cursor: pointer;">--</td>
                <td onclick="openTradeModal('${trade.id}')" style="cursor: pointer;">--</td>
                <td style="text-align: center; padding: 4px;">
                    <button class="btn-pnl" onclick="showTradePnL('${trade.id}'); event.stopPropagation();" style="position: static;">PnL</button>
                </td>
                <td style="text-align: center; padding: 4px;">
                    <button class="btn-remove" onclick="removeTrade('${trade.id}'); event.stopPropagation();" style="position: static;">remove</button>
                </td>
            `;
            
            tbody.appendChild(row);
        }
        
        function toggleTradeGroup(groupId) {
            console.log('üîÑ Toggling trade group:', groupId);
            
            const arrow = document.getElementById(`group-arrow-${groupId}`);
            const groupMembers = document.querySelectorAll(`[data-group-id="${groupId}"]`);
            
            if (!arrow || groupMembers.length === 0) {
                console.log('‚ùå Group elements not found');
                return;
            }
            
            const isCollapsed = arrow.classList.contains('collapsed');
            
            if (isCollapsed) {
                // Expand group
                console.log('üìñ Expanding group:', groupId);
                arrow.classList.remove('collapsed');
                arrow.textContent = '‚ñº';
                groupMembers.forEach(member => {
                    member.classList.remove('hidden');
                });
            } else {
                // Collapse group
                console.log('üìï Collapsing group:', groupId);
                arrow.classList.add('collapsed');
                arrow.textContent = '‚ñ∂';
                groupMembers.forEach(member => {
                    member.classList.add('hidden');
                });
            }
        }
        
        // Function to remove a trade
        function removeTrade(tradeId) {
            console.log('üóëÔ∏è Removing trade:', tradeId);
            
            if (confirm('Are you sure you want to remove this trade?')) {
                fetch(`/delete_trade/${tradeId}`, { 
                    method: 'DELETE' 
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        console.log('‚úÖ Trade removed from backend');
                        // Reload trades from backend file
                        loadTradesFromBackend();
                        updateCharts();
                    } else {
                        alert('Error removing trade: ' + (data.error || 'Unknown error'));
                    }
                })
                .catch(error => {
                    console.error('‚ùå Error removing trade:', error);
                    alert('Error removing trade: ' + error.message);
                });
            }
        }
        
        function loadTradeForEditing(tradeId) {
            console.log('üìù Loading trade for editing from JSON:', tradeId);
            
            // Fetch fresh data from backend
            fetch(`/get_trade_details/${tradeId}`)
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    const trade = data.trade;
                    console.log('üìä Trade data from JSON:', trade);
                    
                    // Build modal completely from scratch using JSON data
                    buildModalFromJSON(trade);
                    
                } else {
                    alert('Error loading trade details: ' + (data.error || 'Unknown error'));
                }
            })
            .catch(error => {
                console.error('‚ùå Error loading trade for editing:', error);
                alert('Error loading trade for editing: ' + error.message);
            });
        }
        
        function buildModalFromJSON(trade) {
            console.log('üèóÔ∏è Building modal from scratch using JSON data:', trade);
            
            // Step 1: Clear and rebuild the entire modal structure
            clearModalForm();
            
            // Step 2: Get data from JSON
            const typologies = Array.isArray(trade.typology) ? trade.typology : [trade.typology];
            const instruments = Array.isArray(trade.instrument_details) ? trade.instrument_details : [trade.instrument_details];
            const prices = trade.prices || [];
            const sizes = trade.sizes || [];
            const prices_secondary = trade.prices_secondary || [];
            const sizes_secondary = trade.sizes_secondary || [];
            const primaryInsertionDates = trade.primary_pos_insertion_dt || [];
            const secondaryInsertionDates = trade.secondary_pos_insertion_dt || [];
            
            console.log('üìã JSON Data extracted:', { 
                trade_id: trade.trade_id,
                typologies, 
                instruments, 
                prices, 
                sizes, 
                prices_secondary, 
                sizes_secondary,
                instrument_details_secondary: trade.instrument_details_secondary,
                primaryInsertionDates,
                secondaryInsertionDates
            });
            
            // üìÖ ENHANCED INSERTION DATE DEBUGGING
            console.log('üìÖ ================= INSERTION DATES DETAILED BREAKDOWN =================');
            console.log('üìÖ Primary positions count:', prices.length);
            console.log('üìÖ Primary insertion dates count:', primaryInsertionDates.length);
            console.log('üìÖ Primary insertion dates array:', JSON.stringify(primaryInsertionDates));
            
            if (prices_secondary.length > 0 || secondaryInsertionDates.length > 0) {
                console.log('üìÖ Secondary positions count:', prices_secondary.length);
                console.log('üìÖ Secondary insertion dates count:', secondaryInsertionDates.length);
                console.log('üìÖ Secondary insertion dates array:', JSON.stringify(secondaryInsertionDates));
            }
            
            // Position-by-position breakdown
            for (let i = 0; i < Math.max(prices.length, primaryInsertionDates.length); i++) {
                const price = i < prices.length ? prices[i] : 'N/A';
                const size = i < sizes.length ? sizes[i] : 'N/A';
                const date = i < primaryInsertionDates.length ? primaryInsertionDates[i] : 'NO DATE';
                console.log(`üìÖ PRIMARY Position ${i + 1}: Price=${price}, Size=${size}, Date="${date}"`);
            }
            
            for (let i = 0; i < Math.max(prices_secondary.length, secondaryInsertionDates.length); i++) {
                const price = i < prices_secondary.length ? prices_secondary[i] : 'N/A';
                const size = i < sizes_secondary.length ? sizes_secondary[i] : 'N/A';
                const date = i < secondaryInsertionDates.length ? secondaryInsertionDates[i] : 'NO DATE';
                console.log(`üìÖ SECONDARY Position ${i + 1}: Price=${price}, Size=${size}, Date="${date}"`);
            }
            console.log('üìÖ ====================================================================');
            
            // Step 3: Wait for clearModalForm's setTimeout to finish, then populate everything
            setTimeout(() => {
                // Set modal title AFTER clearModalForm's timeout has cleared it
                document.getElementById('modalTitle').value = trade.trade_id;
                console.log('‚úÖ Set modal title to:', trade.trade_id);
                
                // Populate primary type and instrument
                const primaryRow = document.querySelector('#basicInfoTableBody tr:first-child');
                if (primaryRow && typologies.length > 0 && instruments.length > 0) {
                    const typeSelect = primaryRow.querySelector('.modal-trade-type');
                    const instrumentInput = primaryRow.querySelector('.modal-instrument');
                    
                    // Group ID is now in the top section
                    const groupIdInput = document.getElementById('singleGroupId');
                    
                    if (typeSelect) {
                        typeSelect.value = typologies[0];
                        console.log(`‚úÖ Set primary type: "${typologies[0]}"`);
                    }
                    if (instrumentInput) {
                        instrumentInput.value = instruments[0];
                        console.log(`‚úÖ Set primary instrument: "${instruments[0]}"`);
                    }
                    if (groupIdInput && trade.group_id) {
                        groupIdInput.value = trade.group_id;
                        console.log(`‚úÖ Set group ID: "${trade.group_id}"`);
                    }
                    
                    // Trigger handleTypeChange if EFP to show secondary sections
                    if (typologies[0] === 'efp' && typeSelect) {
                        console.log('üìä EFP trade detected, showing secondary sections');
                        handleTypeChange(typeSelect);
                        
                        // Wait for secondary row to appear, then populate it
                        setTimeout(() => {
                            if (trade.instrument_details_secondary && trade.instrument_details_secondary.length > 0) {
                                const secondaryRow = document.getElementById('secondaryInstrumentRow');
                                if (secondaryRow) {
                                    const secondaryInstrumentInput = secondaryRow.querySelector('.modal-instrument-secondary');
                                    if (secondaryInstrumentInput) {
                                        secondaryInstrumentInput.value = trade.instrument_details_secondary[0];
                                        console.log('‚úÖ Set secondary instrument:', trade.instrument_details_secondary[0]);
                                    } else {
                                        console.error('‚ùå Secondary instrument input not found');
                                    }
                                } else {
                                    console.error('‚ùå Secondary row not found');
                                }
                            }
                        }, 100);
                    }
                }
                
                // Load positions after a delay to ensure modal is ready
                setTimeout(() => {
                    const isEFP = typologies.includes('efp');
                    
                    if (isEFP) {
                        console.log(`üìä EFP trade: Loading ${prices.length} primary and ${prices_secondary.length} secondary positions`);
                        
                        // Load primary (swap) positions
                        loadPositionsFromJSON(prices, sizes, primaryInsertionDates, 'primary', 0);
                        
                        // Load secondary (futures) positions with delay
                        const delay = 300 + (prices.length * 60);
                        setTimeout(() => {
                            loadPositionsFromJSON(prices_secondary, sizes_secondary, secondaryInsertionDates, 'secondary', 0);
                        }, delay);
                        
                    } else {
                        console.log(`üìä Non-EFP trade: Loading ${prices.length} positions`);
                        loadPositionsFromJSON(prices, sizes, primaryInsertionDates, 'primary', 0);
                    }
                    
                    // Set up listeners and trigger updates after positions are loaded
                    const totalDelay = isEFP ? 500 + (prices.length * 60) + (prices_secondary.length * 60) : 300 + (prices.length * 60);
                    setTimeout(() => {
                        setupAutoUpdateListeners();
                        triggerLiveRateUpdates();
                        
                        // Trigger P&L calculations after live rates load
                        setTimeout(() => {
                            triggerPnLCalculations();
                        }, 800);
                    }, totalDelay);
                }, 200);
            }, 100);
        }
        
        // New function to add existing position with actual values (not zeros)
        function add_position_existing(tableType, price, size, insertionDate, tradeType, instrument) {
            console.log(`üì• Loading existing ${tableType} position: price=${price}, size=${JSON.stringify(size)}, date=${insertionDate}`);
            
            // CRITICAL FIX: Ensure insertion date is properly formatted for date input
            let formattedInsertionDate = '';
            if (insertionDate && insertionDate !== null && insertionDate !== 'null') {
                // Ensure date is in YYYY-MM-DD format for HTML date input
                if (insertionDate.includes('/')) {
                    // Convert from MM/DD/YYYY or DD/MM/YYYY to YYYY-MM-DD
                    const parts = insertionDate.split('/');
                    if (parts.length === 3) {
                        // Assume MM/DD/YYYY format for now
                        formattedInsertionDate = `${parts[2]}-${parts[0].padStart(2, '0')}-${parts[1].padStart(2, '0')}`;
                    }
                } else if (insertionDate.includes('-') && insertionDate.length === 10) {
                    // Already in YYYY-MM-DD format
                    formattedInsertionDate = insertionDate;
                } else {
                    // Try to parse and format
                    const date = new Date(insertionDate);
                    if (!isNaN(date.getTime())) {
                        formattedInsertionDate = date.toISOString().split('T')[0];
                    }
                }
            }
            
            console.log(`üìÖ INSERTION DATE FORMATTING: "${insertionDate}" -> "${formattedInsertionDate}"`);
            
            // Determine which table to add to
            const tbody = tableType === 'secondary' 
                ? document.getElementById('secondaryPositionsTableBody')
                : document.getElementById('positionsTableBody');
            
            const row = document.createElement('tr');
            const positionId = `position_${positionCounter++}`;
            
            console.log(`üîß Adding ${tableType} position for type:`, tradeType, 'instrument:', instrument);
            
            let sizeCell = '';
            
            if (tradeType === 'future' && instrument) {
                // Parse the futures expression to check for multiple components
                const components = parseFuturesExpressionComponents(instrument);
                
                if (components.length > 1 && Array.isArray(size)) {
                    // Multiple components - show individual size inputs with values
                    sizeCell = '<td><div style="display: flex; flex-direction: column; gap: 4px;">';
                    components.forEach((comp, idx) => {
                        const sizeVal = idx < size.length ? size[idx] : '';
                        sizeCell += `
                            <div style="display: flex; align-items: center; gap: 4px;">
                                <span style="font-size: 10px; color: #888; min-width: 80px;">${comp.instrument}:</span>
                                <input type="number" data-position-size="${positionId}" data-component-index="${idx}" 
                                       value="${sizeVal}" placeholder="25" onchange="handlePositionChange(this)" step="1" 
                                       style="width: 60px; font-size: 11px;">
                            </div>
                        `;
                    });
                    sizeCell += '</div></td>';
                } else {
                    // Single component or simple expression
                    const sizeVal = Array.isArray(size) ? (size[0] || '') : (size || '');
                    sizeCell = `
                        <td>
                            <input type="number" data-position-size="${positionId}" value="${sizeVal}" placeholder="25" 
                                   onchange="handlePositionChange(this)" step="1">
                        </td>
                    `;
                }
            } else {
                // Non-futures - single size value
                const sizeVal = Array.isArray(size) ? (size[0] || '') : (size || '');
                sizeCell = `
                    <td>
                        <input type="number" data-position-size="${positionId}" value="${sizeVal}" placeholder="25" 
                               onchange="handlePositionChange(this)" step="1">
                    </td>
                `;
            }
            
            row.innerHTML = `
                <td>
                    <input type="number" data-position-price="${positionId}" value="${price.toFixed(2)}" placeholder="3.14" 
                           onchange="handlePositionChange(this)" step="0.01">
                </td>
                ${sizeCell}
                <td>
                    <input type="date" data-position-insertion-date="${positionId}" value="${formattedInsertionDate}"
                           onchange="handlePositionChange(this)" style="width: 100px; font-size: 11px;">
                </td>
                <td style="position: relative;">
                    <span class="pnl-display" style="color: #cccccc; padding: 4px 8px; display: inline-block; min-width: 60px; text-align: center;">--</span>
                    <button class="btn-remove" onclick="removePosition(this)" style="position: absolute; right: -60px; top: 50%; transform: translateY(-50%);">remove</button>
                </td>
            `;
            
            tbody.appendChild(row);
            console.log(`‚úÖ Added existing ${tableType} position with actual values and formatted insertion date: ${formattedInsertionDate}`);
        }
        
        function loadPositionsFromJSON(prices, sizes, insertionDates, tableType, index) {
            if (index >= prices.length || sizes[index] === undefined) {
                console.log(`‚úÖ Finished loading ${tableType} positions`);
                console.log(`üìÖ FINAL ${tableType.toUpperCase()} INSERTION DATES SUMMARY:`);
                console.log(`   Total positions loaded: ${index}`);
                console.log(`   Insertion dates array: ${JSON.stringify(insertionDates)}`);
                console.log(`   Dates per position: ${insertionDates ? insertionDates.map((date, i) => `Pos${i+1}=${date||'null'}`).join(', ') : 'no dates'}`);
                return;
            }
            
            const price = prices[index];
            const sizeValue = sizes[index];
            const insertionDate = insertionDates && insertionDates[index] ? insertionDates[index] : null;
            
            console.log(`‚ûï Loading existing ${tableType} position ${index + 1}:`);
            console.log(`   üìä Price: ${price}`);
            console.log(`   üìä Size: ${JSON.stringify(sizeValue)}`);
            console.log(`   üìÖ Insertion Date from JSON: "${insertionDate}"`);
            console.log(`   üìÖ Insertion Date null check: ${insertionDate === null ? 'IS NULL' : 'HAS VALUE'}`);
            console.log(`   üìÖ Insertion Date array length: ${insertionDates ? insertionDates.length : 'no array'}`);
            console.log(`   üìÖ Insertion Date at index ${index}: ${insertionDates && insertionDates[index] !== undefined ? `"${insertionDates[index]}"` : 'undefined'}`);
            
            // Determine trade type and instrument for this position
            let tradeType, instrument;
            
            if (tableType === 'secondary') {
                // Secondary = futures leg of EFP
                const secondaryRow = document.getElementById('secondaryInstrumentRow');
                const instrumentInput = secondaryRow?.querySelector('.modal-instrument-secondary');
                tradeType = 'future';
                instrument = instrumentInput?.value.trim() || '';
            } else {
                // Primary = main trade or swap leg of EFP
                const basicInfoRow = document.querySelector('#basicInfoTableBody tr:first-child');
                const tradeTypeSelect = basicInfoRow?.querySelector('.modal-trade-type');
                const instrumentInput = basicInfoRow?.querySelector('.modal-instrument');
                const rawType = tradeTypeSelect?.value.trim() || '';
                tradeType = rawType === 'efp' ? 'swap' : rawType;
                instrument = instrumentInput?.value.trim() || '';
            }
            
            // Use the new add_position_existing function to directly add position with actual values
            add_position_existing(tableType, price, sizeValue, insertionDate, tradeType, instrument);
            
            // Load next position after a short delay
            setTimeout(() => {
                loadPositionsFromJSON(prices, sizes, insertionDates, tableType, index + 1);
            }, 50);
        }
        
        function triggerLiveRateUpdates() {
            console.log('üîÑ Triggering live rate updates...');
            
            // Update primary instrument
            const primaryRow = document.querySelector('#basicInfoTableBody tr:first-child');
            if (primaryRow) {
                const instrumentInput = primaryRow.querySelector('.modal-instrument');
                if (instrumentInput && instrumentInput.value.trim()) {
                    updateLiveRate(instrumentInput);
                }
            }
            
            // Update secondary instrument if EFP
            const secondaryRow = document.getElementById('secondaryInstrumentRow');
            if (secondaryRow && secondaryRow.style.display !== 'none') {
                const secondaryInstrumentInput = secondaryRow.querySelector('.modal-instrument-secondary');
                if (secondaryInstrumentInput && secondaryInstrumentInput.value.trim()) {
                    updateLiveRate(secondaryInstrumentInput);
                }
            }
        }
        
        function triggerPnLCalculations() {
            console.log('üí∞ Triggering P&L calculations...');
            
            // Calculate P&L for primary positions
            const primaryRows = document.querySelectorAll('#positionsTableBody tr');
            primaryRows.forEach((row, index) => {
                const priceInput = row.querySelector('[data-position-price]');
                const sizeInputs = row.querySelectorAll('[data-position-size]');
                
                if (priceInput && priceInput.value && sizeInputs.length > 0) {
                    const hasSize = Array.from(sizeInputs).some(input => input.value);
                    if (hasSize) {
                        console.log(`üí∞ Calculating P&L for primary position ${index + 1}`);
                        handlePositionChange(priceInput);
                    }
                }
            });
            
            // Calculate P&L for secondary positions
            const secondaryRows = document.querySelectorAll('#secondaryPositionsTableBody tr');
            secondaryRows.forEach((row, index) => {
                const priceInput = row.querySelector('[data-position-price]');
                const sizeInputs = row.querySelectorAll('[data-position-size]');
                
                if (priceInput && priceInput.value && sizeInputs.length > 0) {
                    const hasSize = Array.from(sizeInputs).some(input => input.value);
                    if (hasSize) {
                        console.log(`üí∞ Calculating P&L for secondary position ${index + 1}`);
                        handlePositionChange(priceInput);
                    }
                }
            });
        }
        
        // Show/hide secondary instrument based on type
        document.addEventListener('change', function(e) {
            if (e.target.id === 'modalTradeType') {
                const secondaryGroup = document.getElementById('secondaryInstrumentGroup');
                if (e.target.value === 'efp') {
                    secondaryGroup.style.display = 'block';
                } else {
                    secondaryGroup.style.display = 'none';
                }
            }
        });
        
        // Function to load trades from backend and display in grid
        function loadTradesFromBackend() {
            console.log('üîÑ Loading trades from backend...');
            
            fetch('/get_trades')
            .then(response => {
                console.log('üì° Response received:', response.status);
                return response.json();
            })
            .then(data => {
                console.log('üìä Backend data:', data);
                console.log('üìÇ COMPLETE PORTFOLIO OBJECT:', JSON.stringify(data, null, 2));
                
                // üìÖ INSERTION DATES BREAKDOWN - Enhanced logging for insertion dates
                if (data.success && data.trades) {
                    console.log('üìÖ ================= INSERTION DATES BREAKDOWN =================');
                    Object.values(data.trades).forEach(trade => {
                        console.log(`üìÖ Trade: ${trade.trade_id}`);
                        console.log(`   Primary insertion dates: ${JSON.stringify(trade.primary_pos_insertion_dt || [])}`);
                        console.log(`   Secondary insertion dates: ${JSON.stringify(trade.secondary_pos_insertion_dt || [])}`);
                        
                        // Show position count vs insertion date count
                        const primaryPositions = (trade.prices || []).length;
                        const secondaryPositions = (trade.prices_secondary || []).length;
                        const primaryDates = (trade.primary_pos_insertion_dt || []).length;
                        const secondaryDates = (trade.secondary_pos_insertion_dt || []).length;
                        
                        console.log(`   Primary: ${primaryPositions} positions, ${primaryDates} dates`);
                        if (secondaryPositions > 0 || secondaryDates > 0) {
                            console.log(`   Secondary: ${secondaryPositions} positions, ${secondaryDates} dates`);
                        }
                        
                        // Detailed breakdown with position-date mapping
                        if (primaryPositions > 0 || primaryDates > 0) {
                            console.log(`   üìä Primary position details:`);
                            for (let i = 0; i < Math.max(primaryPositions, primaryDates); i++) {
                                const price = trade.prices && trade.prices[i] ? trade.prices[i] : 'N/A';
                                const size = trade.sizes && trade.sizes[i] ? trade.sizes[i] : 'N/A';
                                const date = trade.primary_pos_insertion_dt && trade.primary_pos_insertion_dt[i] ? trade.primary_pos_insertion_dt[i] : 'No date';
                                console.log(`     Position ${i + 1}: Price=${price}, Size=${size}, Date=${date}`);
                            }
                        }
                        
                        if (secondaryPositions > 0 || secondaryDates > 0) {
                            console.log(`   üìä Secondary position details:`);
                            for (let i = 0; i < Math.max(secondaryPositions, secondaryDates); i++) {
                                const price = trade.prices_secondary && trade.prices_secondary[i] ? trade.prices_secondary[i] : 'N/A';
                                const size = trade.sizes_secondary && trade.sizes_secondary[i] ? trade.sizes_secondary[i] : 'N/A';
                                const date = trade.secondary_pos_insertion_dt && trade.secondary_pos_insertion_dt[i] ? trade.secondary_pos_insertion_dt[i] : 'No date';
                                console.log(`     Position ${i + 1}: Price=${price}, Size=${size}, Date=${date}`);
                            }
                        }
                        console.log(''); // Empty line between trades
                    });
                    console.log('üìÖ ========================================================');
                }
                
                if (data.success) {
                    // Clear local storage
                    storedTrades = [];
                    
                    // Handle portfolio metadata and timestamp
                    if (data.portfolio_metadata) {
                        const metadata = data.portfolio_metadata;
                        const timestampDiv = document.getElementById('pnlTimestamp');
                        const timestampValue = document.getElementById('timestampValue');
                        
                        if (metadata.last_pnl_update) {
                            const date = new Date(metadata.last_pnl_update);
                            const formattedTime = date.toLocaleString('en-US', {
                                year: 'numeric',
                                month: '2-digit',
                                day: '2-digit',
                                hour: '2-digit',
                                minute: '2-digit',
                                second: '2-digit'
                            });
                            
                            timestampValue.textContent = formattedTime;
                            timestampDiv.style.display = 'block';
                        } else {
                            timestampDiv.style.display = 'none';
                        }
                    }
                    
                    // Convert backend trades to frontend format
                    Object.values(data.trades).forEach(backendTrade => {
                        console.log('üîÑ Processing trade:', backendTrade.trade_id);
                        
                        // Calculate total entry size safely
                        const totalEntrySize = (backendTrade.entry_sizes || []).reduce((sum, size) => sum + (size || 0), 0);
                        
                        // Get trade type
                        const tradeType = Array.isArray(backendTrade.typology) ? backendTrade.typology[0] || '' : backendTrade.typology || '';
                        
                        // Format stored P&L for display
                        let storedPnLDisplay = '--';
                        if (backendTrade.stored_pnl !== undefined && backendTrade.stored_pnl !== 0) {
                            const pnl = backendTrade.stored_pnl;
                            storedPnLDisplay = `$${pnl.toLocaleString('en-US', {
                                minimumFractionDigits: 0,
                                maximumFractionDigits: 0
                            })}`;
                        }
                        
                        const trade = {
                            id: backendTrade.trade_id,
                            type: tradeType,
                            identifier: backendTrade.trade_id,
                            instrument: Array.isArray(backendTrade.instrument_details) ? backendTrade.instrument_details[0] || '' : backendTrade.instrument_details || '',
                            positions: [],
                            avgEntry: backendTrade.weighted_avg_entry || 0,
                            totalSize: totalEntrySize,
                            storedPnL: storedPnLDisplay,
                            groupId: backendTrade.group_id || null
                        };
                        
                // For EFP trades, also extract separate P&L values
                if (tradeType === 'efp') {
                    // Store primary (swap) P&L - always set, even if 0
                    if (backendTrade.stored_pnl_primary !== undefined) {
                        trade.storedPnLPrimary = backendTrade.stored_pnl_primary;
                    }
                    
                    // Store secondary (futures) P&L - always set, even if 0
                    if (backendTrade.stored_pnl_secondary !== undefined) {
                        trade.storedPnLSecondary = backendTrade.stored_pnl_secondary;
                    }
                    
                    console.log(`üí∞ EFP P&L - Primary: ${trade.storedPnLPrimary || 0}, Secondary: ${trade.storedPnLSecondary || 0}`);
                }
                        
                        // Add entry positions
                        (backendTrade.entry_prices || []).forEach((price, index) => {
                            if (backendTrade.entry_sizes && backendTrade.entry_sizes[index]) {
                                trade.positions.push({
                                    type: 'entry',
                                    price: price,
                                    size: backendTrade.entry_sizes[index]
                                });
                            }
                        });
                        
                        // Add exit positions
                        (backendTrade.exit_prices || []).forEach((price, index) => {
                            if (backendTrade.exit_sizes && backendTrade.exit_sizes[index]) {
                                trade.positions.push({
                                    type: 'exit',
                                    price: price,
                                    size: backendTrade.exit_sizes[index]
                                });
                            }
                        });
                        
                        storedTrades.push(trade);
                        console.log('‚úÖ Added trade to local storage:', trade.identifier);
                    });
                    
                    // Display trades in grid
                    console.log(`üìã Displaying ${storedTrades.length} trades in grid`);
                    displayTradesInGrid();
                    
                    console.log(`üìÇ Successfully loaded ${storedTrades.length} trades from backend`);
                } else {
                    console.error('‚ùå Backend error:', data.error);
                    alert('Error loading trades: ' + (data.error || 'Unknown error'));
                }
            })
            .catch(error => {
                console.error('‚ùå Network error loading trades:', error);
                alert('Network error loading trades: ' + error.message);
            });
        }
        
        // Function to update P&L display in modal after recalculation
        function updateModalPnLDisplay() {
            if (!currentTradeId) return;
            
            console.log('üîÑ Updating modal P&L display for:', currentTradeId);
            
            fetch(`/get_trade_details/${currentTradeId}`)
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    const trade = data.trade;
                    
                    // Get basic trade info to determine type
                    const basicInfoRow = document.querySelector('#basicInfoTableBody tr');
                    const tradeTypeSelect = basicInfoRow?.querySelector('.modal-trade-type');
                    const tradeType = tradeTypeSelect?.value.trim() || 'swap';
                    
                    console.log('üîÑ Recalculating P&L for each position with updated expression...');
                    
                    // Update PRIMARY position P&Ls
                    const positionRows = document.querySelectorAll('#positionsTableBody tr');
                    const instrumentInput = basicInfoRow?.querySelector('.modal-instrument');
                    const instrument = instrumentInput?.value.trim();
                    
                    // Trigger P&L calculation for each primary position
                    positionRows.forEach((row, index) => {
                        const priceInput = row.querySelector('[data-position-price]');
                        const sizeInput = row.querySelector('[data-position-size]');
                        
                        if (priceInput && sizeInput && priceInput.value && sizeInput.value) {
                            console.log(`üîÑ Recalculating P&L for PRIMARY position ${index + 1}`);
                            // Trigger the P&L calculation which will update the display
                            handlePositionChange(priceInput);
                        }
                    });
                    
                    // Update SECONDARY position P&Ls (for EFP trades)
                    if (tradeType === 'efp') {
                        const secondaryPositionRows = document.querySelectorAll('#secondaryPositionsTableBody tr');
                        
                        console.log(`üîÑ Found ${secondaryPositionRows.length} SECONDARY positions to recalculate`);
                        
                        secondaryPositionRows.forEach((row, index) => {
                            const priceInput = row.querySelector('[data-position-price]');
                            const sizeInputs = row.querySelectorAll('[data-position-size]');
                            
                            // Check if we have valid data
                            let hasValidData = priceInput && priceInput.value;
                            if (hasValidData && sizeInputs.length > 0) {
                                // Check if at least one size input has a value
                                hasValidData = Array.from(sizeInputs).some(input => input.value);
                            }
                            
                            if (hasValidData) {
                                console.log(`üîÑ Recalculating P&L for SECONDARY position ${index + 1}`);
                                // Trigger the P&L calculation which will update the display
                                handlePositionChange(priceInput);
                            }
                        });
                    }
                    
                    // Update total P&L display in modal
                    const totalTradePnLElements = document.querySelectorAll('.total-pnl-display');
                    const storedPnL = trade.stored_pnl || 0;
                    
                    totalTradePnLElements.forEach(element => {
                        element.textContent = `$${storedPnL.toLocaleString('en-US', {
                            minimumFractionDigits: 0,
                            maximumFractionDigits: 0
                        })}`;
                        element.style.color = storedPnL >= 0 ? '#51cf66' : '#ff6b6b';
                    });
                    
                    console.log('‚úÖ Modal P&L display updated with stored P&L:', storedPnL);
                }
            })
            .catch(error => {
                console.error('‚ùå Error fetching updated trade details:', error);
            });
        }
        
        // Function to set up auto-update listeners for live rates and P&L
        function setupAutoUpdateListeners() {
            console.log('üîß Setting up auto-update listeners...');
            
            // Check if curves are loaded first
            fetch('/curves_status')
            .then(response => response.json())
            .then(data => {
                if (data.loaded) {
                    console.log('‚úÖ Curves are loaded, enabling auto-updates');
                    
                    // Set up listeners for instrument inputs
                    const instrumentInputs = document.querySelectorAll('.modal-instrument');
                    instrumentInputs.forEach(input => {
                        input.addEventListener('input', function() {
                            // Debounce the update to avoid too many requests
                            clearTimeout(this.updateTimeout);
                            this.updateTimeout = setTimeout(() => {
                                updateLiveRate(this);
                            }, 500);
                        });
                    });
                    
                    // Set up listeners for position inputs
                    const positionInputs = document.querySelectorAll('[data-position-price], [data-position-size]');
                    positionInputs.forEach(input => {
                        input.addEventListener('input', function() {
                            // Debounce the P&L calculation
                            clearTimeout(this.pnlTimeout);
                            this.pnlTimeout = setTimeout(() => {
                                handlePositionChange(this);
                            }, 500);
                        });
                    });
                    
                    // Trigger initial updates if data is already present
                    setTimeout(() => {
                        // Update live rates for any existing instruments
                        const basicInfoRows = document.querySelectorAll('#basicInfoTableBody tr');
                        basicInfoRows.forEach(row => {
                            const typeSelect = row.querySelector('.modal-trade-type');
                            const instrumentInput = row.querySelector('.modal-instrument');
                            
                            if (typeSelect && instrumentInput && 
                                typeSelect.value.trim() && instrumentInput.value.trim()) {
                                console.log('üîÑ Auto-updating live rate for existing instrument:', instrumentInput.value);
                                updateLiveRate(instrumentInput);
                            }
                        });
                        
                        // Update P&L for any existing positions
                        const positionRows = document.querySelectorAll('#positionsTableBody tr');
                        positionRows.forEach(row => {
                            const priceInput = row.querySelector('[data-position-price]');
                            const sizeInput = row.querySelector('[data-position-size]');
                            
                            if (priceInput && sizeInput && 
                                priceInput.value.trim() && sizeInput.value.trim()) {
                                console.log('üîÑ Auto-updating P&L for position');
                                handlePositionChange(priceInput);
                            }
                        });
                    }, 200);
                    
                } else {
                    console.log('‚ö†Ô∏è Curves not loaded, auto-updates disabled');
                }
            })
            .catch(error => {
                console.error('‚ùå Error checking curves status:', error);
            });
        }
        
        // Add immediate console log to check if script is loading
        console.log('üöÄ Trading page JavaScript loaded');
        
        // Test function to verify curve data accessibility
        function testLiveRateAPI() {
            console.log('üß™ Testing live rate API...');
            
            fetch('/get_realtime_rates', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    expressions: [{
                        label: 'test',
                        expression: 'aud.5y5y'
                    }]
                })
            })
            .then(response => {
                console.log('üß™ Test API response status:', response.status);
                return response.json();
            })
            .then(data => {
                console.log('üß™ Test API response data:', data);
                if (data.success && data.rates && data.rates.test) {
                    console.log('‚úÖ API test successful! Rate:', data.rates.test);
                } else {
                    console.log('‚ùå API test failed:', data.error || 'No rate returned');
                }
            })
            .catch(error => {
                console.error('‚ùå API test network error:', error);
            });
        }
        
        // Run test after a short delay to ensure page is loaded
        setTimeout(testLiveRateAPI, 2000);
        
        // Manual test function for the button in modal
        function testLiveRateInModal() {
            console.log('üß™ Manual test triggered from modal button');
            
            // Find the first row in the basic info table
            const firstRow = document.querySelector('#basicInfoTableBody tr');
            if (firstRow) {
                const typeSelect = firstRow.querySelector('.modal-trade-type');
                const instrumentInput = firstRow.querySelector('.modal-instrument');
                
                // Set test values
                typeSelect.value = 'swap';
                instrumentInput.value = 'aud.5y5y';
                
                console.log('üß™ Set test values: swap, aud.5y5y');
                
                // Trigger the live rate update
                updateLiveRate(instrumentInput);
            } else {
                console.log('‚ùå No rows found in basic info table');
            }
        }
        
        // Function to check curves and auto-update P&L on page load
        function checkCurvesAndAutoUpdate() {
            console.log('üîç Checking if realtime curves exist on page load...');
            
            fetch('/curves_status')
            .then(response => response.json())
            .then(data => {
                if (data.loaded) {
                    console.log('‚úÖ Realtime curves exist, auto-updating P&L...');
                    
                    // Auto-update P&L since curves exist
                    fetch('/update_realtime_pnl', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    })
                    .then(response => response.json())
                    .then(pnlData => {
                        if (pnlData.success) {
                            console.log('‚úÖ Auto P&L update successful on page load');
                            // Load trades with fresh P&L data
                            loadTradesFromBackend();
                        } else {
                            console.log('‚ö†Ô∏è Auto P&L update failed, loading stored P&L');
                            // Still load trades with stored P&L
                            loadTradesFromBackend();
                        }
                    })
                    .catch(error => {
                        console.error('‚ùå Auto P&L update error:', error);
                        // Still load trades with stored P&L
                        loadTradesFromBackend();
                    });
                } else {
                    console.log('üìä No realtime curves, loading stored P&L from JSON');
                    // No curves, just load stored P&L from JSON
                    loadTradesFromBackend();
                }
            })
            .catch(error => {
                console.error('‚ùå Error checking curves status:', error);
                // Fallback to loading stored P&L
                loadTradesFromBackend();
            });
        }
        
        // Load trades on page load with auto P&L update if curves exist
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üéØ DOMContentLoaded event fired');
            updateCharts();
            checkCurvesAndAutoUpdate(); // Check curves and auto-update P&L
        });
        
        // Also try loading immediately in case DOMContentLoaded already fired
        if (document.readyState === 'loading') {
            console.log('üìÑ Document still loading, waiting for DOMContentLoaded');
        } else {
            console.log('üìÑ Document already loaded, executing immediately');
            setTimeout(() => {
                updateCharts();
                checkCurvesAndAutoUpdate();
            }, 100);
        }
        
        // Removed formatting functions - inputs now display exactly what user enters
        
        // MODULAR: Edit position then calculate P&L
        function handlePositionChange(input) {
            console.log('üî• =================================== HANDLE POSITION CHANGE START ===================================');
            console.log('‚úèÔ∏è POSITION EDITED - Input element that triggered change:', input);
            console.log('‚úèÔ∏è Input element details:', {
                tagName: input.tagName,
                type: input.type,
                value: input.value,
                dataset: input.dataset,
                className: input.className
            });
            
            const row = input.closest('tr');
            console.log('üîç Row found:', row);
            
            const priceInput = row.querySelector('[data-position-price]');
            const pnlDisplay = row.querySelector('.pnl-display');
            
            console.log('üîç Row elements found:', {
                priceInput: !!priceInput,
                priceValue: priceInput?.value,
                pnlDisplay: !!pnlDisplay,
                pnlCurrentText: pnlDisplay?.textContent
            });
            
            if (!priceInput || !pnlDisplay) {
                console.log('‚ùå Missing elements for P&L calculation - ABORTING');
                return;
            }
            
            // Determine if this position is in primary or secondary table
            const positionsTableBody = document.getElementById('positionsTableBody');
            const secondaryPositionsTableBody = document.getElementById('secondaryPositionsTableBody');
            
            console.log('üîç Table references:', {
                positionsTableBody: !!positionsTableBody,
                secondaryPositionsTableBody: !!secondaryPositionsTableBody
            });
            
            const isSecondaryPosition = secondaryPositionsTableBody && secondaryPositionsTableBody.contains(row);
            const tableType = isSecondaryPosition ? 'secondary' : 'primary';
            
            console.log('üîç Position type determination:', {
                isSecondaryPosition: isSecondaryPosition,
                tableType: tableType,
                containsCheck: secondaryPositionsTableBody ? secondaryPositionsTableBody.contains(row) : 'N/A'
            });
            
            // Get position index (row position in table)
            const positionTable = isSecondaryPosition ? secondaryPositionsTableBody : positionsTableBody;
            const positionRows = Array.from(positionTable.querySelectorAll('tr'));
            const positionIndex = positionRows.indexOf(row);
            
            console.log('üîç Position index calculation:', {
                positionTable: positionTable === positionsTableBody ? 'PRIMARY' : 'SECONDARY',
                totalRows: positionRows.length,
                positionIndex: positionIndex,
                rowsFoundInTable: positionRows.map((r, i) => `Row ${i}: ${r === row ? 'THIS ROW' : 'other'}`)
            });
            
            if (positionIndex === -1) {
                console.error('‚ùå CRITICAL: Row not found in position table - this will cause backend errors!');
                console.log('üîç Debug info:', {
                    row: row,
                    positionTable: positionTable,
                    allRows: positionRows
                });
            }
            
            // Get price, size, and insertion date values
            const price = parseFloat(priceInput.value);
            const sizeInputs = row.querySelectorAll('[data-position-size]');
            const insertionDateInput = row.querySelector('[data-position-insertion-date]');
            const insertionDate = insertionDateInput ? insertionDateInput.value : null;
            
            console.log('üîç Size inputs found:', {
                count: sizeInputs.length,
                values: Array.from(sizeInputs).map((input, i) => ({
                    index: i,
                    value: input.value,
                    dataset: input.dataset
                }))
            });
            
            console.log('üîç Insertion date input found:', {
                insertionDateInput: !!insertionDateInput,
                insertionDate: insertionDate
            });
            
            // Collect size value(s) - can be single or array for futures
            let size;
            if (sizeInputs.length > 1) {
                // Multiple sizes (futures with components)
                size = Array.from(sizeInputs).map(input => parseFloat(input.value) || 0);
                console.log('üî¢ Multiple component sizes collected:', size);
            } else if (sizeInputs.length === 1) {
                // Single size
                size = parseFloat(sizeInputs[0].value) || 0;
                console.log('üî¢ Single size collected:', size);
            } else {
                size = 0;
                console.log('üî¢ No size inputs found, defaulting to 0');
            }
            
            // Validate we have data
            const sizeIsValid = Array.isArray(size) ? size.some(s => s !== 0) : size !== 0;
            
            console.log('üîç Data validation:', {
                price: price,
                priceIsValid: !isNaN(price),
                size: size,
                sizeIsValid: sizeIsValid,
                insertionDate: insertionDate, 
                canProceed: !isNaN(price) && sizeIsValid

            });
            
            if (!isNaN(price) && sizeIsValid) {
                console.log(`üöÄ Starting backend update for ${tableType.toUpperCase()} position ${positionIndex}`);
                
                pnlDisplay.textContent = 'Updating...';
                pnlDisplay.style.color = '#cccccc';
                
                const editPayload = {
                    trade_id: currentTradeId,
                    position_index: positionIndex,
                    positionType: tableType,
                    price: price,
                    size: size,
                    insertion_date: insertionDate
                };
                
                console.log('üì§ EDIT POSITION REQUEST:', editPayload);
                
                // Step 1: Edit the position in backend
                fetch('/edit_position', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(editPayload)
                })
                .then(response => {
                    console.log('üì° Edit position response status:', response.status);
                    return response.json();
                })
                .then(data => {
                    console.log('üì• EDIT POSITION RESPONSE:', data);
                    
                    if (!data.success) {
                        throw new Error(data.error || 'Failed to edit position');
                    }
                    
                    console.log(`‚úÖ Position ${positionIndex} (${tableType}) updated in backend successfully`);
                    
                    // Step 2: Calculate P&L for the updated position
                    pnlDisplay.textContent = 'Calculating...';
                    
                    const pnlPayload = {
                        trade_id: currentTradeId,
                        position_index: positionIndex,
                        positionType: tableType
                    };
                    
                    console.log('üì§ CALCULATE PNL REQUEST:', pnlPayload);
                    
                    return fetch('/calculate_position_pnl', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(pnlPayload)
                    });
                })
                .then(response => {
                    console.log('üì° Calculate P&L response status:', response.status);
                    return response.json();
                })
                .then(data => {
                    console.log('üì• CALCULATE PNL RESPONSE:', data);
                    
                    if (data.success && data.pnl !== undefined) {
                        const pnl = data.pnl;
                        const formattedPnL = `$${pnl.toLocaleString('en-US', {
                            minimumFractionDigits: 0,
                            maximumFractionDigits: 0
                        })}`;
                        
                        pnlDisplay.textContent = formattedPnL;
                        
                        if (pnl > 0) {
                            pnlDisplay.style.color = '#51cf66';
                        } else if (pnl < 0) {
                            pnlDisplay.style.color = '#ff6b6b';
                        } else {
                            pnlDisplay.style.color = '#cccccc';
                        }
                        
                        console.log(`‚úÖ P&L calculated and displayed: ${pnl} -> ${formattedPnL}`);
                        
                        // Log additional details if available
                        if (data.position_details) {
                            console.log('üîç Position details from backend:', data.position_details);
                        }
                        if (data.components) {
                            console.log('üîç Component details from backend:', data.components);
                        }
                        if (data.component_pnls) {
                            console.log('üîç Component P&Ls from backend:', data.component_pnls);
                        }
                        
                        updateTotalTradePnL();
                    } else {
                        throw new Error(data.error || 'Failed to calculate P&L');
                    }
                })
                .catch(error => {
                    console.error('‚ùå ERROR in position change flow:', error);
                    console.error('‚ùå Error stack:', error.stack);
                    pnlDisplay.textContent = 'Error';
                    pnlDisplay.style.color = '#ff6b6b';
                    updateTotalTradePnL();
                });
            } else {
                console.log('‚ö†Ô∏è Invalid data - clearing P&L display');
                pnlDisplay.textContent = '--';
                pnlDisplay.style.color = '#cccccc';
                updateTotalTradePnL();
            }
            
            console.log('üî• =================================== HANDLE POSITION CHANGE END =====================================');
        }
        
        // Function to calculate and display total trade P&L
        function updateTotalTradePnL() {
            console.log('üßÆ Updating total trade P&L...');
            
            // Calculate PRIMARY (swap) P&L
            const primaryPositionRows = document.querySelectorAll('#positionsTableBody tr');
            let primaryTotalPnL = 0;
            let primaryPositionCount = 0;
            let hasValidPrimaryPnL = false;
            
            primaryPositionRows.forEach(row => {
                const pnlDisplay = row.querySelector('.pnl-display');
                
                if (pnlDisplay) {
                    const pnlText = pnlDisplay.textContent.trim();
                    
                    // Extract numeric value from P&L display (e.g., "$1,234" -> 1234)
                    if (pnlText && pnlText !== '--' && pnlText !== 'Error' && pnlText !== 'Calculating...' && pnlText !== 'No curves') {
                        const pnlValue = parseFloat(pnlText.replace(/[$,]/g, ''));
                        
                        if (!isNaN(pnlValue)) {
                            hasValidPrimaryPnL = true;
                            primaryTotalPnL += pnlValue;
                            primaryPositionCount++;
                        }
                    }
                }
            });
            
            // Calculate SECONDARY (futures) P&L
            const secondaryPositionRows = document.querySelectorAll('#secondaryPositionsTableBody tr');
            let secondaryTotalPnL = 0;
            let secondaryPositionCount = 0;
            let hasValidSecondaryPnL = false;
            
            secondaryPositionRows.forEach(row => {
                const pnlDisplay = row.querySelector('.pnl-display');
                
                if (pnlDisplay) {
                    const pnlText = pnlDisplay.textContent.trim();
                    
                    // Extract numeric value from P&L display (e.g., "$1,234" -> 1234)
                    if (pnlText && pnlText !== '--' && pnlText !== 'Error' && pnlText !== 'Calculating...' && pnlText !== 'No curves') {
                        const pnlValue = parseFloat(pnlText.replace(/[$,]/g, ''));
                        
                        if (!isNaN(pnlValue)) {
                            hasValidSecondaryPnL = true;
                            secondaryTotalPnL += pnlValue;
                            secondaryPositionCount++;
                        }
                    }
                }
            });
            
            // Update PRIMARY row total P&L (first row in basic info table)
            const primaryRow = document.querySelector('#basicInfoTableBody tr:first-child');
            if (primaryRow) {
                const primaryPnLDisplay = primaryRow.querySelector('.total-pnl-display');
                if (primaryPnLDisplay) {
                    if (hasValidPrimaryPnL) {
                        primaryPnLDisplay.textContent = `$${primaryTotalPnL.toLocaleString('en-US', {
                            minimumFractionDigits: 0,
                            maximumFractionDigits: 0
                        })}`;
                        primaryPnLDisplay.style.color = primaryTotalPnL >= 0 ? '#51cf66' : '#ff6b6b';
                    } else {
                        primaryPnLDisplay.textContent = '--';
                        primaryPnLDisplay.style.color = '#cccccc';
                    }
                }
            }
            
            // Update SECONDARY row total P&L (futures row)
            const secondaryRow = document.getElementById('secondaryInstrumentRow');
            if (secondaryRow) {
                const secondaryPnLDisplay = secondaryRow.querySelector('.total-pnl-display');
                if (secondaryPnLDisplay) {
                    if (hasValidSecondaryPnL) {
                        secondaryPnLDisplay.textContent = `$${secondaryTotalPnL.toLocaleString('en-US', {
                            minimumFractionDigits: 0,
                            maximumFractionDigits: 0
                        })}`;
                        secondaryPnLDisplay.style.color = secondaryTotalPnL >= 0 ? '#51cf66' : '#ff6b6b';
                    } else {
                        secondaryPnLDisplay.textContent = '--';
                        secondaryPnLDisplay.style.color = '#cccccc';
                    }
                }
            }
            
            // Update EFP TOTAL row (third row - combined P&L and spread)
            const efpTotalRow = document.getElementById('efpTotalRow');
            if (efpTotalRow) {
                // Update spread display
                updateEFPSpread();
                
                // Update combined P&L
                const efpTotalPnLDisplay = document.getElementById('efpTotalPnL');
                if (efpTotalPnLDisplay) {
                    // Only show combined total if we have valid P&L for at least one leg
                    if (hasValidPrimaryPnL || hasValidSecondaryPnL) {
                        const combinedTotal = primaryTotalPnL + secondaryTotalPnL;
                        efpTotalPnLDisplay.textContent = `$${combinedTotal.toLocaleString('en-US', {
                            minimumFractionDigits: 0,
                            maximumFractionDigits: 0
                        })}`;
                        efpTotalPnLDisplay.style.color = combinedTotal >= 0 ? '#51cf66' : '#ff6b6b';
                    } else {
                        efpTotalPnLDisplay.textContent = '--';
                        efpTotalPnLDisplay.style.color = '#cccccc';
                    }
                }
            }
            
            console.log('‚úÖ Total trade P&L updated:', {
                primaryPnL: primaryTotalPnL,
                primaryPositionCount: primaryPositionCount,
                secondaryPnL: secondaryTotalPnL,
                secondaryPositionCount: secondaryPositionCount,
                combinedTotal: primaryTotalPnL + secondaryTotalPnL
            });
        }
        
        // Function to calculate and display EFP spread
        function updateEFPSpread() {
            const efpSpreadDisplay = document.getElementById('efpSpread');
            if (!efpSpreadDisplay) return;
            
            // Get primary (swap) live rate
            const primaryRow = document.querySelector('#basicInfoTableBody tr:first-child');
            const primaryLiveRate = primaryRow?.querySelector('.live-rate-display');
            const primaryRateText = primaryLiveRate?.textContent.trim();
            
            // Get secondary (futures) live rate
            const secondaryRow = document.getElementById('secondaryInstrumentRow');
            const secondaryLiveRate = secondaryRow?.querySelector('.live-rate-display');
            const secondaryRateText = secondaryLiveRate?.textContent.trim();
            
            // Check if both rates are valid numbers
            if (primaryRateText && secondaryRateText && 
                primaryRateText !== '--' && secondaryRateText !== '--' &&
                primaryRateText !== 'Loading...' && secondaryRateText !== 'Loading...' &&
                primaryRateText !== 'No curves' && secondaryRateText !== 'No curves' &&
                primaryRateText !== 'Error' && secondaryRateText !== 'Error') {
                
                const primaryRate = parseFloat(primaryRateText);
                const secondaryRate = parseFloat(secondaryRateText);
                
                if (!isNaN(primaryRate) && !isNaN(secondaryRate)) {
                    // Calculate spread (swap - futures)
                    const spread = primaryRate - secondaryRate;
                    
                    // Display spread with appropriate color
                    efpSpreadDisplay.textContent = spread.toFixed(2);
                    if (spread > 0) {
                        efpSpreadDisplay.style.color = '#51cf66'; // Green for positive
                    } else if (spread < 0) {
                        efpSpreadDisplay.style.color = '#ff6b6b'; // Red for negative
                    } else {
                        efpSpreadDisplay.style.color = '#00d4ff'; // Blue for zero
                    }
                    
                    console.log(`üìä EFP Spread calculated: ${spread.toFixed(2)} (${primaryRate} - ${secondaryRate})`);
                    return;
                }
            }
            
            // Default to -- if rates not available
            efpSpreadDisplay.textContent = '--';
            efpSpreadDisplay.style.color = '#cccccc';
        }
        
        // Function to update real-time P&L (matching charts page format)
        function updateRealtimePnL() {
            console.log('üîÑ Starting real-time P&L update...');
            
            const button = document.getElementById('load-pnl-btn');
            const buttonText = document.querySelector('.pnl-button-text');
            const loadingSpinner = document.querySelector('.pnl-loading-spinner');
            
            // Show loading state on button (matching charts page format)
            buttonText.style.display = 'none';
            loadingSpinner.style.display = 'inline';
            button.disabled = true;
            
            fetch('/update_realtime_pnl', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                }
            })
            .then(response => response.json())
            .then(data => {
                console.log('üìä P&L update response:', data);
                
                if (data.success) {
                    console.log('‚úÖ P&L update successful');
                    
                    // Update timestamp display
                    const timestampDiv = document.getElementById('pnlTimestamp');
                    const timestampValue = document.getElementById('timestampValue');
                    
                    if (data.timestamp) {
                        const date = new Date(data.timestamp);
                        const formattedTime = date.toLocaleString('en-US', {
                            year: 'numeric',
                            month: '2-digit',
                            day: '2-digit',
                            hour: '2-digit',
                            minute: '2-digit',
                            second: '2-digit'
                        });
                        
                        timestampValue.textContent = formattedTime;
                        timestampDiv.style.display = 'block';
                    }
                    
                    // Reload trades to show updated P&L
                    loadTradesFromBackend();
                    
                    // Show success message briefly
                    buttonText.textContent = `‚úÖ Updated (${data.trades_updated} trades)`;
                    buttonText.style.display = 'inline';
                    loadingSpinner.style.display = 'none';
                    
                    setTimeout(() => {
                        buttonText.textContent = 'Load Real Time Data + P&L';
                    }, 3000);
                    
                } else {
                    console.error('‚ùå P&L update failed:', data.error);
                    alert('P&L update failed: ' + (data.error || 'Unknown error'));
                    buttonText.textContent = 'Load Real Time Data + P&L';
                    buttonText.style.display = 'inline';
                    loadingSpinner.style.display = 'none';
                }
            })
            .catch(error => {
                console.error('‚ùå P&L update network error:', error);
                alert('Network error during P&L update: ' + error.message);
                buttonText.textContent = 'Load Real Time Data + P&L';
                buttonText.style.display = 'inline';
                loadingSpinner.style.display = 'none';
            })
            .finally(() => {
                // Re-enable button
                button.disabled = false;
            });
        }
        
        // Function to display trade PnL in the bottom left chart
        function showTradePnL(tradeId) {
            console.log('üìä Fetching PnL data for trade:', tradeId);
            
            fetch(`/get_trade_pnl_array/${tradeId}`)
            .then(response => response.json())
            .then(data => {
                if (data.success && data.pnl_array && data.pnl_array.length > 0) {
                    console.log('‚úÖ PnL array received:', data.pnl_array.length, 'dates');
                    
                    // Extract dates and PnL values - ensure dates are in ISO format for Plotly
                    const dates = data.pnl_array.map(item => {
                        const dateStr = item[0];
                        // If it's already an ISO string or parseable date, return it
                        // Otherwise convert it to ISO format
                        const date = new Date(dateStr);
                        return date.toISOString().split('T')[0]; // Return YYYY-MM-DD format
                    });
                    const pnlValues = data.pnl_array.map(item => item[1]);
                    
                    // Create trace for total PnL only
                    const totalTrace = {
                        x: dates,
                        y: pnlValues,
                        type: 'scatter',
                        mode: 'lines',
                        name: 'Total P&L',
                        line: { color: '#00d4ff', width: 2 },
                        hovertemplate: '%{x|%m/%d/%y}<br>%{y:$,.0f}<extra></extra>'
                    };
                    
                    const traces = [totalTrace];
                    
                    // Update the portfolio chart with trade PnL - feint aqua gridlines, transparent bg, white text
                    Plotly.newPlot('portfolioChart', traces, {
                        plot_bgcolor: 'rgba(0,0,0,0)',
                        paper_bgcolor: 'rgba(0,0,0,0)',
                        font: { color: '#ffffff' },
                        xaxis: { 
                            type: 'date',
                            gridcolor: 'rgba(0, 212, 255, 0.15)', 
                            color: '#ffffff', 
                            tickformat: '%d %b %y',
                            hoverformat: '%d %b %y',
                            showline: false,
                            zeroline: false
                        },
                        yaxis: { 
                            gridcolor: 'rgba(0, 212, 255, 0.15)', 
                            color: '#ffffff',
                            showline: false,
                            zeroline: false
                        },
                        title: { text: `Trade P&L: ${tradeId}`, font: { color: '#00d4ff', size: 14 } },
                        margin: { l: 50, r: 45, t: 50, b: 45, pad: 0 },
                        showlegend: false
                    });
                    
                    console.log('‚úÖ Trade PnL chart updated');
                } else {
                    console.error('‚ùå No PnL data available for trade:', tradeId);
                    alert('No P&L data available for this trade. Try updating real-time P&L first.');
                }
            })
            .catch(error => {
                console.error('‚ùå Error fetching trade PnL:', error);
                alert('Error fetching trade P&L: ' + error.message);
            });
        }
        
        // Function to display group PnL in the bottom left chart
        function showGroupPnL(groupId) {
            console.log('üìä Fetching PnL data for group:', groupId);
            
            fetch(`/get_group_pnl_array/${groupId}`)
            .then(response => response.json())
            .then(data => {
                if (data.success && data.pnl_array && data.pnl_array.length > 0) {
                    console.log('‚úÖ Group PnL array received:', data.pnl_array.length, 'dates');
                    console.log('üìä Group contains', data.num_trades, 'trades:', data.trade_ids);
                    
                    // Extract dates and PnL values - ensure dates are in ISO format for Plotly
                    const dates = data.pnl_array.map(item => {
                        const dateStr = item[0];
                        const date = new Date(dateStr);
                        return date.toISOString().split('T')[0]; // Return YYYY-MM-DD format
                    });
                    const pnlValues = data.pnl_array.map(item => item[1]);
                    
                    // Create trace for total group PnL
                    const totalTrace = {
                        x: dates,
                        y: pnlValues,
                        type: 'scatter',
                        mode: 'lines',
                        name: 'Total P&L',
                        line: { color: '#00d4ff', width: 2 },
                        hovertemplate: '%{x|%m/%d/%y}<br>%{y:$,.0f}<extra></extra>'
                    };
                    
                    const traces = [totalTrace];
                    
                    // Update the portfolio chart with group PnL
                    Plotly.newPlot('portfolioChart', traces, {
                        plot_bgcolor: 'rgba(0,0,0,0)',
                        paper_bgcolor: 'rgba(0,0,0,0)',
                        font: { color: '#ffffff' },
                        xaxis: { 
                            type: 'date',
                            gridcolor: 'rgba(0, 212, 255, 0.15)', 
                            color: '#ffffff', 
                            tickformat: '%d %b %y',
                            hoverformat: '%d %b %y',
                            showline: false,
                            zeroline: false
                        },
                        yaxis: { 
                            gridcolor: 'rgba(0, 212, 255, 0.15)', 
                            color: '#ffffff',
                            showline: false,
                            zeroline: false
                        },
                        title: { text: `Group P&L: ${groupId} (${data.num_trades} trades)`, font: { color: '#00d4ff', size: 14 } },
                        margin: { l: 50, r: 45, t: 50, b: 45, pad: 0 },
                        showlegend: false
                    });
                    
                    console.log('‚úÖ Group PnL chart updated');
                } else {
                    console.error('‚ùå No PnL data available for group:', groupId);
                    alert('No P&L data available for this group. Try updating real-time P&L first.');
                }
            })
            .catch(error => {
                console.error('‚ùå Error fetching group PnL:', error);
                alert('Error fetching group P&L: ' + error.message);
            });
        }
        
        // Add event listener for the P&L update button
        document.getElementById('load-pnl-btn').addEventListener('click', updateRealtimePnL);
        
        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('tradeModal');
            if (event.target === modal) {
                closeTradeModal();
            }
        }
    </script>
</body>
</html>
